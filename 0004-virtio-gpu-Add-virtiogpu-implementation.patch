From 165a9c5ea8b5b416655eaeecf8b54f400b53e954 Mon Sep 17 00:00:00 2001
From: Sebastian Eydam <sebastian.eydam@cyberus-technology.de>
Date: Mon, 15 Aug 2022 14:13:14 +0200
Subject: [PATCH 04/17] virtio-gpu: Add virtiogpu implementation

virtiogpu: enable hotplug support

Some hardcoded display IDs were removed and if we change the display
layout via "VBoxManage modifyvm <vm-name> setscreenlayout" we pass the
required information to enable/disable monitors to the virtio gpu.

Further, the VBoxManage setscreenlayout call is extended to pass the
display information to the virtiogpu in case it is used as a graphics
adapter.

virtio-gpu: Disable x2apic msr hint conditionally

If the VirtioGPU is used as a graphics controller and the guest is
configured with >8 CPUs, we disable the X2APIC_MSR HyperV hint.

We do this because there are known issues with the DVServerKMD virtio
gpu driver in Windows 10, that prevent the Windows from booting if the
specific HyperV hint is set. Not setting the hint allows the Windows to
boot. Therefore, we only disable the hint in the specific combination of
VirtioGPU + >8 CPUs in order to not affect guest performance in all
other cases.

VBox: virtio: add PDMR3QueryDevice to VMM vTable again

VBox:Virtio: Move from SVP include directory to cyberus include directory

VBox:Virtio: rename SVP Display to CBS Display

virtio: remove slvm dependency

vga: re-add dummy connector attachment

We previously had some VBOX_WITH_SVP define around the code connecting
our dummy connector when switching from the VGA display to some custom
display (either GVT or VirtipGPU).

Having this define led to subtle bugs when using SR-IOV with a non SVP
backend like KVM. It led to crashes in the SVGA device when e.g.
shutting down a VM currently running on the VirtioGPU.

As this define prevented SR-IOV to work with KVM, and also prevented
SR-IOV with vanilla VBox, we remove it.

virtiocore: workaround lost event

The Intel DV driver does not recognize the display changed event we are
issuing. We noticed, that when setting both queue interrupt + display
event in the ISR solves this problem. It is unclear why this is the case
at the moment.

license: virtiogpu
---
 include/VBox/log.h                            |   3 +
 include/VBox/vmm/pdmcommon.h                  |   5 +
 include/VBox/vmm/pdmifs.h                     |  11 +
 include/VBox/vmm/vmmr3vtable-def.h            |   1 +
 include/cyberus/edid.hpp                      | 423 +++++++++++
 include/{svp => cyberus}/pci.h                |   0
 src/VBox/Devices/Bus/DevVfio.h                |   2 +-
 src/VBox/Devices/Graphics/DevVGA.cpp          |  48 ++
 src/VBox/Devices/Graphics/DevVirtioGpu.cpp    | 407 +++++++++++
 src/VBox/Devices/Graphics/DevVirtioGpu.hpp    | 373 ++++++++++
 .../Graphics/DevVirtioGpuCmdHandler.cpp       | 687 ++++++++++++++++++
 .../Graphics/DevVirtioGpuCmdHandler.hpp       | 353 +++++++++
 .../Graphics/DevVirtioGpuDefinitions.hpp      | 360 +++++++++
 .../Graphics/DevVirtioGpuDisplayManager.cpp   | 413 +++++++++++
 .../Graphics/DevVirtioGpuDisplayManager.hpp   | 213 ++++++
 .../Devices/Graphics/DevVirtioGpuResource.hpp |  80 ++
 .../Graphics/DevVirtioGpuVBoxStubs.cpp        | 342 +++++++++
 .../Graphics/DevVirtioGpuVBoxStubs.hpp        |  71 ++
 src/VBox/Devices/Makefile.kmk                 |  10 +
 src/VBox/Devices/VirtIO/VirtioCore.cpp        |   2 +-
 src/VBox/Devices/build/VBoxDD.cpp             |   3 +
 src/VBox/Devices/build/VBoxDD.h               |   1 +
 src/VBox/Devices/testcase/Makefile.kmk        |  37 +-
 .../Devices/testcase/tstVirtioGpuAdapter.hpp  | 181 +++++
 .../testcase/tstVirtioGpuCmdHandling.cpp      | 450 ++++++++++++
 .../Frontends/VBoxManage/VBoxManageInfo.cpp   |  12 +
 .../VBoxManage/VBoxManageModifyVM.cpp         |   6 +
 .../src/converter/UIConverterBackendCOM.cpp   |   4 +
 src/VBox/Main/idl/VirtualBox.xidl             |   6 +
 src/VBox/Main/include/ConsoleImpl.h           |   7 +-
 .../Main/src-client/BusAssignmentManager.cpp  |   4 +-
 src/VBox/Main/src-client/ConsoleImpl2.cpp     |  98 ++-
 src/VBox/Main/src-client/DisplayImpl.cpp      |  41 ++
 .../Main/src-server/GraphicsAdapterImpl.cpp   |   2 +
 .../Main/src-server/SystemPropertiesImpl.cpp  |   2 +
 src/VBox/Main/xml/Settings.cpp                |   6 +
 src/VBox/Main/xml/VirtualBox-settings.xsd     |   2 +
 src/VBox/Runtime/VBox/log-vbox.cpp            |   1 +
 src/VBox/VMM/VMMR3/GIMHv.cpp                  |  14 +-
 39 files changed, 4666 insertions(+), 15 deletions(-)
 create mode 100644 vboxsrc/include/cyberus/edid.hpp
 rename vboxsrc/include/{svp => cyberus}/pci.h (100%)
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpu.cpp
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpu.hpp
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpuCmdHandler.cpp
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpuCmdHandler.hpp
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpuDefinitions.hpp
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpuDisplayManager.cpp
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpuDisplayManager.hpp
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpuResource.hpp
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpuVBoxStubs.cpp
 create mode 100644 vboxsrc/src/VBox/Devices/Graphics/DevVirtioGpuVBoxStubs.hpp
 create mode 100644 vboxsrc/src/VBox/Devices/testcase/tstVirtioGpuAdapter.hpp
 create mode 100644 vboxsrc/src/VBox/Devices/testcase/tstVirtioGpuCmdHandling.cpp

diff --git a/include/VBox/log.h b/include/VBox/log.h
index aaec2b54bd..93129cb334 100644
--- a/include/VBox/log.h
+++ b/include/VBox/log.h
@@ -184,6 +184,8 @@ typedef enum VBOXLOGGROUP
     LOG_GROUP_DEV_VGA,
     /** Virtio PCI Device group. */
     LOG_GROUP_DEV_VIRTIO,
+    /** Virtio GPU Device group. */
+    LOG_GROUP_DEV_VIRTIO_GPU,
     /** Virtio Network Device group. */
     LOG_GROUP_DEV_VIRTIO_NET,
     /** VMM Device group. */
@@ -913,6 +915,7 @@ typedef enum VBOXLOGGROUP
     "DEV_VFIO", \
     "DEV_VGA", \
     "DEV_VIRTIO", \
+    "DEV_VIRTIO_GPU", \
     "DEV_VIRTIO_NET", \
     "DEV_VMM", \
     "DEV_VMM_BACKDOOR", \
diff --git a/include/VBox/vmm/pdmcommon.h b/include/VBox/vmm/pdmcommon.h
index cbad79983e..8746e53afc 100644
--- a/include/VBox/vmm/pdmcommon.h
+++ b/include/VBox/vmm/pdmcommon.h
@@ -111,6 +111,11 @@
 #define PDM_TACH_FLAGS_NO_CALLBACKS     RT_BIT_32(1)
 /** @} */
 
+/** This flag is used in the pfnAttach call for the vga device and indicates
+ * that only a dummy driver should be attached. This is used to "disable" the
+ * vga device.
+ */
+#define PDM_ATTACH_DUMMY_DRIVER RT_BIT_32(31)
 
 /**
  * Is asynchronous handling of suspend or power off notification completed?
diff --git a/include/VBox/vmm/pdmifs.h b/include/VBox/vmm/pdmifs.h
index c4eaeb1fca..86a3a94afb 100644
--- a/include/VBox/vmm/pdmifs.h
+++ b/include/VBox/vmm/pdmifs.h
@@ -42,6 +42,9 @@
 #include <iprt/sg.h>
 #include <VBox/types.h>
 
+// For VMMDevDisplayDef
+#include <VBox/VMMDev.h>
+
 
 RT_C_DECLS_BEGIN
 
@@ -552,6 +555,14 @@ typedef struct PDMIKEYBOARDCONNECTOR
 #define PDMIKEYBOARDCONNECTOR_IID               "db3f7bd5-953e-436f-9f8e-077905a92d82"
 
 
+typedef struct PDMIVIRTIOGPUPORT
+{
+    DECLR3CALLBACKMEMBER(void, pfnDisplayChanged, (PPDMDEVINS pDevIns, uint32_t numDisplays, VMMDevDisplayDef* displayDefs));
+} PDMIVIRTIOGPUPORT;
+
+typedef struct PDMIVIRTIOGPUPORT *PPDMIVIRTIOGPUPORT;
+
+# define PDMIVIRTIOGPUPORT_IID               "db3f7bd5-baba-436f-9f8e-077905a92d82"
 
 /** Pointer to a display port interface. */
 typedef struct PDMIDISPLAYPORT *PPDMIDISPLAYPORT;
diff --git a/include/VBox/vmm/vmmr3vtable-def.h b/include/VBox/vmm/vmmr3vtable-def.h
index e603a58997..b4207844f5 100644
--- a/include/VBox/vmm/vmmr3vtable-def.h
+++ b/include/VBox/vmm/vmmr3vtable-def.h
@@ -595,6 +595,7 @@ VTABLE_ENTRY(PDMR3DeviceDetach)
 VTABLE_ENTRY(PDMR3DriverAttach)
 VTABLE_ENTRY(PDMR3DriverDetach)
 VTABLE_ENTRY(PDMR3NsBwGroupSetLimit)
+VTABLE_ENTRY(PDMR3QueryDevice)
 VTABLE_ENTRY(PDMR3QueryDeviceLun)
 VTABLE_ENTRY(PDMR3QueryDriverOnLun)
 VTABLE_ENTRY(PDMR3QueryLun)
diff --git a/include/cyberus/edid.hpp b/include/cyberus/edid.hpp
new file mode 100644
index 0000000000..b05b59ebb3
--- /dev/null
+++ b/include/cyberus/edid.hpp
@@ -0,0 +1,423 @@
+#pragma once
+
+#include <array>
+#include <cassert>
+#include <cstdint>
+#include <cstring>
+#include <numeric>
+#include <string>
+
+/*
+ * The Extended Display Identification Data structure Version 1.4 Structure Definitions
+ * The EDID structures are implemented based on the VESA-EEDID-A2 Specification
+ * from https://glenwing.github.io/docs/VESA-EEDID-A2.pdf
+ */
+
+/*
+ * The EDID Standard Timings Definition (Section 3.9 VESA EEDID A2 Specification)
+ * For a list of Standard Codes please refer to the VESA DMT 1.13 Specification.
+ * Link: https://glenwing.github.io/docs/VESA-DMT-1.13.pdf
+ * The horizontal addressable pixels are calculated by the following formula:
+ * horizontalPixels = (pixelcount / 8) - 31;
+ */
+struct __attribute__((__packed__)) EdidStandardTiming
+{
+    uint8_t horizontalPixels;
+
+    /*
+     * The aspectRatio is stored in bits 6 and 7
+     */
+    enum __attribute__((__packed__)) AspectRatio : uint8_t
+    {
+        AR_16_10 = 0x0,
+        AR_4_3 = 0x1 << 6,
+        AR_5_4 = 0x2 << 6,
+        AR_16_9 = 0x3 << 6
+    };
+
+    /*
+     * The refresh rate is stored in the lower 5 bits and stored using this
+     * formula: refreshRate = <value> + 60 HZ
+     * Example 85 HZ: 0x19 + 60 = 85 hz; refresh rate = 0x19;
+     */
+    uint8_t aspectRatioAndRefreshRate;
+
+    EdidStandardTiming() = default;
+
+    EdidStandardTiming(uint32_t horizontalPixels_, AspectRatio ratio, uint8_t refreshRate)
+    {
+        assert(refreshRate >= 60);
+        horizontalPixels = (horizontalPixels_ / 8) - 31;
+        aspectRatioAndRefreshRate = (ratio & 0xc0) | ((refreshRate - 60) & 0x3f);
+    }
+};
+
+/*
+ * The Detailed Timing Descriptor (Section 3.10.2)
+ *
+ * The default values are extracted from a running GVT with its default EDID
+ */
+struct __attribute__((__packed__)) EdidDetailedTimingDescriptor
+{
+    uint16_t pixelClock {0};
+    uint8_t hVideoLow {0x80};
+    uint8_t hBlankingLow {0xa0};
+    uint8_t hVideoBlankingHigh {0x70};
+    uint8_t vVideoLow {0xb0};
+    uint8_t vVBlankingLow {0x23};
+    uint8_t vVideoBlankingHigh {0x40};
+    uint8_t hFrontPorchLow {0x30};
+    uint8_t hSyncPulseWidthLow {0x20};
+    uint8_t vFrontPorchSyncPulseWidthlow {0x36};
+    uint8_t vhFrontPorchSyncPulseHigh {0x00};
+    uint8_t hVideoImageSizeLow {0x06};
+    uint8_t vVideoImageSizeLow {0x44};
+    uint8_t vhVideoImageSizeHigh {0x21};
+    uint8_t horizontalBorder {0x00};  // (Section 3.12)
+    uint8_t verticalBorder {0x00};    // (Section 3.12)
+    uint8_t signalDefinitions {0x1a}; // (Table 3.22)
+};
+
+static_assert(sizeof(EdidDetailedTimingDescriptor) == 18,
+              "The size of the EdidDetailedTimingDescriptor must be 18 bytes!");
+
+/*
+ * The Display Descriptor Definitions (Section 3.10.3)
+ */
+struct __attribute__((__packed__)) EdidDisplayDescriptorDefinitions
+{
+    uint16_t reserved {0};
+    uint8_t reserved1 {0};
+
+    enum __attribute__((__packed__)) : uint8_t
+    {
+        DisplayProductName = 0xFC,
+        DisplayRangeLimits = 0xFD,
+        DisplaySerialNumber = 0xFF,
+    } tag {DisplayProductName};
+
+    union __attribute__((__packed__))
+    {
+        uint8_t reserved2 {0};    // for Serial Number and Product Name
+        uint8_t rangeLimitOffset; // for Display Range Limits (Table 3.26)
+    };
+
+    union __attribute__((__packed__))
+    {
+        char productName[13] {"CBS Display"};
+        char serialNumber[13];
+        struct __attribute__((__packed__))
+        {
+            uint8_t minimumVerticalRate;
+            uint8_t maximumVerticalRate;
+            uint8_t minimumHorizontalRate;
+            uint8_t maximumHorizontalRate;
+            uint8_t maximumPixelClock;
+            uint8_t videoTimingSupportFlags;
+            uint8_t videoTimingDataOrLineFeed; // (Table 3.27 and 3.28
+            uint8_t videoTimingDataOrSpace[6];
+        } rangeLimitsTimingDescriptor;
+    };
+};
+
+static_assert(sizeof(EdidDisplayDescriptorDefinitions) == 18,
+              "The size of the EdidDisplayDescriptorDefinitions must be 18 bytes!");
+
+/*
+ * The EDID Base Block.
+ * All definitions in this structure are based on the VESA-EEDID-A2 Specification.
+ * The structure is implemented Based on Table 3.1 in Section 3.i EDID Format Overview
+ */
+struct __attribute__((__packed__)) EdidBaseBlock
+{
+    uint64_t header {0x00ffffffffffff00}; // (Section 3.3)
+
+    /*
+     * Vendor and Product ID (Section 3.4)
+     */
+    uint16_t manufacturerName {0x530c};   // "CBS" (Section 3.4.1)
+    uint16_t productCode {0x1};           // (Section 3.4.2)
+    uint32_t serialNumber {0x1337};       // (Section 3.4.3)
+    uint16_t manufacturingDates {0x262d}; // (Section 3.4.4) ->(WW45 2022)
+                                          //
+    /*
+     * EDID Version and Revision (Section 3.5)
+     */
+    uint8_t version {0x1};
+    uint8_t revision {0x4};
+
+    /*
+     * Basic Display Parameters and Features (Section 3.6)
+     */
+    uint8_t videoInputDefinition {0xa5}; // (Section 3.6.1 and Table 3.11)
+
+    /*
+     * The Aspect ratio or screen size (Section 3.6.2 and Table 3.12) As we can't
+     * determine the aspect ratio nor the horizontal and vertical screen size
+     * We set the value to 0 which is per Specification used for variable or
+     * unknown ARs and Screen sizes.
+     */
+    uint16_t aspectRatio {0x0000};
+    uint8_t displayTransferCharacteristic {0x78}; // (Section 3.6.3)
+    uint8_t supportedFeatures {0x23};             // (Section 3.6.4 and Table 3.14)
+
+    /*
+     * Color Characteristics (Section 3.7)
+     * Note: these values are copied and modified from
+     * src/VBox/Additions/linux/drm/vbox_mode.c:vbox_set_edid
+     */
+    uint8_t redGreenLowOrder {0xfc};
+    uint8_t blueWhiteLowOrder {0x81};
+    uint8_t redXHighOrder {0xa4};
+    uint8_t redYHighOrder {0x55};
+    uint8_t greenXHighOrder {0x4d};
+    uint8_t greenYHighOrder {0x9d};
+    uint8_t blueXHighOrder {0x25};
+    uint8_t blueYHighOrder {0x12};
+    uint8_t whiteXHighOrder {0x50};
+    uint8_t whiteYHighOrder {0x54};
+
+    /*
+     * Established Timings (Section 3.8 and Table 3.18)
+     */
+    uint8_t establishedTimings1 {0x21}; // 640x480,60HZ; 800x600,60HZ
+    uint8_t establishedTimings2 {0x8};  // 1024x768,60HZ
+    uint8_t manufacturersTimings {0x0};
+
+    /*
+     * Standard Timings (Section 3.9)
+     */
+    EdidStandardTiming standardTimings[8];
+
+    /*
+     * The 18 Byte Descriptors (Section 3.10)
+     */
+    EdidDetailedTimingDescriptor preferredTimingMode {};
+
+    /*
+     * The Second to 4th 18 byte descriptor.
+     * At the Moment we use Display Descriptor Definitions only, but
+     * DetailedTimingDescriptors are possible here as well.
+     */
+    EdidDisplayDescriptorDefinitions displayDescriptors[3];
+
+    uint8_t extensionBlockCount {0};
+
+    uint8_t checksum;
+};
+
+constexpr uint32_t EDID_LENGTH {sizeof(EdidBaseBlock)};
+
+/*
+ * The EIA/CEA 861F Extended EDID Structures.
+ *
+ * The EDID contains the EDID Base Block and an additional EIA/CEA 861F
+ * Compliant EDID Block.
+ *
+ * The EIA/CEA 861G Block Layouts are specified in the CEA-861-F Specification (Section 7.5).
+ * Link:
+ * https://web.archive.org/web/20171201033424/https://standards.cta.tech/kwspub/published_docs/CTA-861-G_FINAL_revised_2017.pdf
+ */
+
+/*
+ *  The CEA Data Block Header Type Byte structure. (Table 54  CEA 861-G)
+ */
+struct __attribute__((__packed__)) CEADataBlockHeader
+{
+    /*
+     * The CEA Data Block Codes (Table 55 EIA/CEA 861-G Specification)
+     */
+    enum __attribute__((__packed__)) DataBlockTagCode : uint8_t
+    {
+        Audio = 1 << 5,
+        Video = 2 << 5,
+        VendorSpecific = 3 << 5,
+        SpeakerAllocation = 4 << 5,
+        VESADisplayTransferCharacteristic = 5 << 5,
+        UseExtendedTag = 7 << 5,
+    };
+
+    enum __attribute__((__packed__)) : uint8_t
+    {
+        LENGTH_MASK = 0x1F,
+        TAG_MASK = 0xE0,
+    };
+
+    uint8_t tagAndLength;
+};
+
+/*
+ * The Video Data Block of the EIA/CEA 861-G Specification (Section 7.5.1)
+ */
+struct __attribute__((__packed__)) CEAVideoDataBlock : public CEADataBlockHeader
+{
+    static constexpr uint8_t MAX_SHORT_VIDEO_DESCRIPTORS {0x1F};
+    std::array<uint8_t, MAX_SHORT_VIDEO_DESCRIPTORS> shortVideoDescriptors;
+};
+
+/*
+ * The CEA Timing Extension.
+ *
+ * The Timing Extension can contain the following CEA Data Blocks:
+ * - Video Data Block
+ * - Audio Data Block
+ * - Speaker Allocation Data Block
+ * - Vendor Specific Data Block
+ *
+ * Our current use case requires Video Data Blocks only.
+ * For simplicity the Structure contains Video Data Blocks only.
+ *
+ *
+ * The Basic Layout can be seen in Table 52 and Table 53 of the EIA/CEA-861-G Specification
+ */
+struct __attribute__((__packed__)) CEAExtendedEdid : public EdidBaseBlock
+{
+    uint8_t eiaCeaTag {0x2};
+    uint8_t eiaCeaRevision {0x3};
+    uint8_t eiaCeaDetailedTimingDescriptorOffset {0x0};
+    uint8_t eiaCeaNativeFormatsandFeatures {0x0};
+    CEAVideoDataBlock videoDataBlock;
+
+    /* padding or other data blocks or DTD's */
+    std::array<uint8_t, sizeof(EdidBaseBlock) - sizeof(videoDataBlock) - 5> padding;
+    uint8_t eiaCeaChecksum {0x0};
+};
+
+static_assert(sizeof(CEAExtendedEdid) == 256, "The CEAExtendedEdid is not 256 bytes large.");
+
+/**
+ * Generates a EDID (Extended Display Identification Data) where the Preferred
+ * Timing Mode has the given resolution.
+ *
+ * The mechanism works following way:
+ * - unplug the virtual display from the vGPU
+ * - set the new EDID generated from the given resolution
+ * - plug in the virtual display
+ *
+ * For the guest OS it looks like a new monitor is connected to the graphics
+ * controller.
+ *
+ *  The EDID is implemented based on the VESA-EEDID-A2 Specification.
+ *  https://glenwing.github.io/docs/VESA-EEDID-A2.pdf
+ *
+ * \param xRes horizontal resolution of the virtual display
+ * \param yRes vertical resolution of the virtual display
+ * \return A Edid where the Preferred Timing Mode has the given resolution
+ */
+template <typename EDID>
+static inline EDID prepareEdid(uint32_t xRes, uint32_t yRes, uint32_t extensionBlockCount = 0)
+{
+    EDID edid;
+
+    edid.standardTimings[0] = {1920, EdidStandardTiming::AR_16_10, 60}; // 1920x1200, 60hz
+    edid.standardTimings[1] = {1920, EdidStandardTiming::AR_16_9, 60};  // 1920x1080, 60hz
+    edid.standardTimings[2] = {1680, EdidStandardTiming::AR_16_10, 60}; // 1680x1050, 60hz
+    edid.standardTimings[3] = {1600, EdidStandardTiming::AR_16_9, 60};  // 1600x900, 60hz
+    edid.standardTimings[4] = {1600, EdidStandardTiming::AR_4_3, 60};   // 1600x1200, 60hz
+    edid.standardTimings[5] = {1024, EdidStandardTiming::AR_4_3, 60};   // 1024x768, 60hz
+    edid.standardTimings[6] = {800, EdidStandardTiming::AR_4_3, 60};    // 800x600, 60hz
+    edid.standardTimings[7] = {640, EdidStandardTiming::AR_4_3, 60};    // 640x480, 60hz
+
+    const uint32_t hblank =
+        ((edid.preferredTimingMode.hVideoBlankingHigh & 0x0f) << 8) | edid.preferredTimingMode.hBlankingLow;
+    const uint32_t vblank =
+        ((edid.preferredTimingMode.vVideoBlankingHigh & 0x0f) << 8) | edid.preferredTimingMode.vVBlankingLow;
+    const uint8_t refresh_rate = 60;
+    uint16_t clock = (xRes + hblank) * (yRes + vblank) * refresh_rate / 10000;
+
+    edid.preferredTimingMode.pixelClock = clock;
+
+    edid.preferredTimingMode.hVideoLow = xRes & 0xff;
+    edid.preferredTimingMode.hVideoBlankingHigh &= 0xf;
+    edid.preferredTimingMode.hVideoBlankingHigh |= (xRes >> 4) & 0xf0;
+
+    edid.preferredTimingMode.vVideoLow = yRes & 0xff;
+    edid.preferredTimingMode.vVideoBlankingHigh &= 0xf;
+    edid.preferredTimingMode.vVideoBlankingHigh |= (yRes >> 4) & 0xf0;
+
+    edid.displayDescriptors[0].tag = EdidDisplayDescriptorDefinitions::DisplayRangeLimits;
+    edid.displayDescriptors[0].rangeLimitOffset = 0x0;
+    edid.displayDescriptors[0].rangeLimitsTimingDescriptor.minimumVerticalRate = 0x18;
+    edid.displayDescriptors[0].rangeLimitsTimingDescriptor.maximumVerticalRate = 0x3c;
+    edid.displayDescriptors[0].rangeLimitsTimingDescriptor.minimumHorizontalRate = 0x18;
+    edid.displayDescriptors[0].rangeLimitsTimingDescriptor.maximumHorizontalRate = 0x50;
+    edid.displayDescriptors[0].rangeLimitsTimingDescriptor.maximumPixelClock = 0x11;
+    edid.displayDescriptors[0].rangeLimitsTimingDescriptor.videoTimingSupportFlags = 0x0;
+    edid.displayDescriptors[0].rangeLimitsTimingDescriptor.videoTimingDataOrLineFeed = 0x0a;
+    std::memset(&edid.displayDescriptors[0].rangeLimitsTimingDescriptor.videoTimingDataOrSpace, 0x20,
+                sizeof(edid.displayDescriptors[0].rangeLimitsTimingDescriptor.videoTimingDataOrSpace));
+
+    edid.displayDescriptors[1].tag = EdidDisplayDescriptorDefinitions::DisplayProductName;
+
+    edid.displayDescriptors[2].tag = EdidDisplayDescriptorDefinitions::DisplaySerialNumber;
+    /* The EDID requires a different serial number on change, thus we add the x Resolution to the serial number. */
+    std::string serialNumber = "Cyberus " + std::to_string(xRes);
+    std::strncpy(&edid.displayDescriptors[2].serialNumber[0], serialNumber.c_str(),
+                 std::min(serialNumber.length(), sizeof(edid.displayDescriptors[2].serialNumber)));
+
+    edid.extensionBlockCount = extensionBlockCount;
+
+    const uint8_t edidChecksumIndex {offsetof(EdidBaseBlock, checksum)};
+    auto edidPtr {reinterpret_cast<uint8_t*>(&edid)};
+    auto sum {std::accumulate(edidPtr, edidPtr + edidChecksumIndex, 0)};
+    edid.checksum = (0x100 - (sum & 0xff)) & 0xff;
+
+    return edid;
+}
+
+static inline std::array<uint8_t, EDID_LENGTH> generateEdid(uint32_t xRes, uint32_t yRes)
+{
+    auto edid {prepareEdid<EdidBaseBlock>(xRes, yRes)};
+
+    std::array<uint8_t, sizeof(edid)> array;
+    std::memcpy(array.data(), &edid, array.size());
+
+    return array;
+}
+
+static inline CEAExtendedEdid generateExtendedEdid(uint32_t xRes, uint32_t yRes)
+{
+    CEAExtendedEdid edid {prepareEdid<CEAExtendedEdid>(xRes, yRes, 1)};
+
+    uint8_t timingCount {0};
+
+    /*
+     * All timings that can be used in Short Video Descriptors are defined
+     * in (Table 3: Video Formats CEA-861-G Specifications) indexed by their Video ID Code (VIC)
+     */
+    auto add_timing = [&timingCount, &edid](const uint8_t vic, const bool native = false) {
+        /*
+         * The Video Data Block is able to support up to 0x1
+         */
+        if (timingCount <= CEAVideoDataBlock::MAX_SHORT_VIDEO_DESCRIPTORS) {
+            /*
+             * For timings with VIC < 65 a native indicator can be set (Refer Section 7.2.3 CEA 861-F Spec.)
+             * This requires a special handling.
+             */
+            if (vic < 65 and native) {
+                edid.videoDataBlock.shortVideoDescriptors[timingCount++] = (1 << 7) | (vic & 0x7f);
+            } else {
+                edid.videoDataBlock.shortVideoDescriptors[timingCount++] = vic;
+            }
+        }
+    };
+
+    /*
+     * The VIC numbers taken from (Table 3: Video Formats CEA 861-G Specification)
+     *
+     * A Native resolution basically means the displays standard resolution
+     */
+    add_timing(5, true); // 1920x1080, 60hz
+    add_timing(90);      // 2560x1080, 60hz
+    add_timing(97);      // 3840x2160, 60hz
+
+    edid.videoDataBlock.tagAndLength =
+        CEADataBlockHeader::DataBlockTagCode::Video | (timingCount & CEADataBlockHeader::LENGTH_MASK);
+    edid.eiaCeaDetailedTimingDescriptorOffset = 4 + sizeof(CEAVideoDataBlock);
+    const uint8_t checksumIndex {sizeof(CEAExtendedEdid) - sizeof(EdidBaseBlock) - 1};
+    auto edidPtr {reinterpret_cast<uint8_t*>(&edid) + sizeof(EdidBaseBlock)};
+    auto sum {std::accumulate(edidPtr, edidPtr + checksumIndex, 0)};
+    edid.eiaCeaChecksum = (0x100 - (sum & 0xff)) & 0xff;
+
+    return edid;
+}
diff --git a/include/svp/pci.h b/include/cyberus/pci.h
similarity index 100%
rename from include/svp/pci.h
rename to include/cyberus/pci.h
diff --git a/src/VBox/Devices/Bus/DevVfio.h b/src/VBox/Devices/Bus/DevVfio.h
index cfe384d7a1..d6bfb0a9f2 100644
--- a/src/VBox/Devices/Bus/DevVfio.h
+++ b/src/VBox/Devices/Bus/DevVfio.h
@@ -19,7 +19,7 @@
 
 #pragma once
 
-#include <svp/pci.h>
+#include <cyberus/pci.h>
 
 #include <VBox/err.h>
 #include <VBox/pci.h>
diff --git a/src/VBox/Devices/Graphics/DevVGA.cpp b/src/VBox/Devices/Graphics/DevVGA.cpp
index a2ce3b3937..6c0ab349b6 100644
--- a/src/VBox/Devices/Graphics/DevVGA.cpp
+++ b/src/VBox/Devices/Graphics/DevVGA.cpp
@@ -6213,6 +6213,49 @@ static DECLCALLBACK(void) vgaR3Relocate(PPDMDEVINS pDevIns, RTGCINTPTR offDelta)
 # endif
 }
 
+template <typename CLASS, typename... ARGS>
+auto generateDummy(int (*CLASS::*)(ARGS...))
+{
+    return [](ARGS...) -> int { return VERR_NOT_IMPLEMENTED; };
+}
+
+template <typename CLASS, typename... ARGS>
+auto generateDummy(void (*CLASS::*)(ARGS...))
+{
+    return [](ARGS...) -> void {};
+}
+
+#define DUMMY_MEMBER(x) dummyConnector.x = generateDummy(&PDMIDISPLAYCONNECTOR::x)
+
+/**
+ * Get a dummy display connector which either does nothing or returns an error
+ * code.
+ */
+static PPDMIDISPLAYCONNECTOR getDummyDisplayConnector()
+{
+    static PDMIDISPLAYCONNECTOR dummyConnector;
+
+    DUMMY_MEMBER(pfnResize);
+    DUMMY_MEMBER(pfnUpdateRect);
+    DUMMY_MEMBER(pfnRefresh);
+    DUMMY_MEMBER(pfnReset);
+    DUMMY_MEMBER(pfnLFBModeChange);
+    DUMMY_MEMBER(pfnProcessAdapterData);
+    DUMMY_MEMBER(pfnProcessDisplayData);
+    DUMMY_MEMBER(pfnVHWACommandProcess);
+    DUMMY_MEMBER(pfnVBVAEnable);
+    DUMMY_MEMBER(pfnVBVADisable);
+    DUMMY_MEMBER(pfnVBVAUpdateBegin);
+    DUMMY_MEMBER(pfnVBVAUpdateProcess);
+    DUMMY_MEMBER(pfnVBVAUpdateEnd);
+    DUMMY_MEMBER(pfnVBVAResize);
+    DUMMY_MEMBER(pfnVBVAMousePointerShape);
+    DUMMY_MEMBER(pfnVBVAGuestCapabilityUpdate);
+    DUMMY_MEMBER(pfnVBVAInputMappingUpdate);
+    DUMMY_MEMBER(pfnVBVAReportCursorPosition);
+
+    return &dummyConnector;
+}
 
 /**
  * @interface_method_impl{PDMDEVREG,pfnAttach}
@@ -6226,6 +6269,11 @@ static DECLCALLBACK(int)  vgaAttach(PPDMDEVINS pDevIns, unsigned iLUN, uint32_t
 
     RT_NOREF(pThis);
 
+    if (fFlags & PDM_ATTACH_DUMMY_DRIVER) {
+        pThisCC->pDrv = getDummyDisplayConnector();
+        return VINF_SUCCESS;
+    }
+
     AssertMsgReturn(fFlags & PDM_TACH_FLAGS_NOT_HOT_PLUG,
                     ("VGA device does not support hotplugging\n"),
                     VERR_INVALID_PARAMETER);
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpu.cpp b/src/VBox/Devices/Graphics/DevVirtioGpu.cpp
new file mode 100644
index 0000000000..20f3e54de8
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpu.cpp
@@ -0,0 +1,407 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#define LOG_GROUP LOG_GROUP_DEV_VIRTIO_GPU
+#include "DevVirtioGpu.hpp"
+#include "DevVirtioGpuVBoxStubs.hpp"
+
+#include <VBox/log.h>
+#include <VBox/vmm/pdmcommon.h>
+
+#include <iprt/semaphore.h>
+#include <iprt/string.h>
+
+#include <array>
+#include <numeric>
+
+int VirtioGpuDevice::init(PPDMDEVINS pDevIns, int iInstance, uint32_t u32VRamSize, uint32_t cMonitorCount,
+                          bool secondaryController)
+{
+    std::string sInstanceName = std::string {"VIRTIOGPU"} + std::to_string(iInstance);
+    szInst = sInstanceName;
+
+    int rc {VINF_SUCCESS};
+
+    gpuConfig.uNumScanouts = cMonitorCount;
+
+    rc = initializeVirtio(pDevIns);
+    AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+    rc = initializeVirtQueues();
+    AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+    rc = initializeDisplay(u32VRamSize, cMonitorCount);
+    AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+    pMemoryAdapter = std::make_unique<VirtioGpuMemoryAdapter>(virtio.pDevInsR3);
+    AssertLogRelReturn(pMemoryAdapter != nullptr, VERR_NO_MEMORY);
+
+    pCmdHandler = std::make_unique<VirtioGpuCmdHandler>(*pVirtioAdapter, *pDisplayManager, *pMemoryAdapter,
+                                                        cMonitorCount, secondaryController);
+    AssertLogRelReturn(pCmdHandler != nullptr, VERR_NO_MEMORY);
+
+    return rc;
+}
+
+int VirtioGpuDevice::initializeVirtio(PPDMDEVINS pDevIns)
+{
+    VIRTIOPCIPARAMS virtioPciParams;
+    virtioPciParams.uDeviceId = virtioGpu::PCI_DEVICE_ID;
+    virtioPciParams.uSubsystemId =
+        virtioGpu::PCI_DEVICE_ID; /* Virtio 1.2 - 4.1.2.1 subsystem id may reflect device id */
+    virtioPciParams.uClassBase = virtioGpu::PCI_CLASS_BASE;
+    virtioPciParams.uClassSub = virtioGpu::PCI_CLASS_SUB;
+    virtioPciParams.uClassProg = virtioGpu::PCI_CLASS_PROG;
+
+    virtioPciParams.uInterruptLine = virtioGpu::PCI_INTERRUPT_LINE;
+    virtioPciParams.uInterruptPin = virtioGpu::PCI_INTERRUPT_PIN;
+
+    PVIRTIOGPUDEVCC pThisCC {PDMDEVINS_2_DATA_CC(pDevIns, PVIRTIOGPUDEVCC)};
+
+    pThisCC->virtio.pfnStatusChanged = virtioGpuStatusChanged;
+    pThisCC->virtio.pfnDevCapRead = virtioGpuDevCapRead;
+    pThisCC->virtio.pfnDevCapWrite = virtioGpuDevCapWrite;
+    pThisCC->virtio.pfnVirtqNotified = virtioGpuVirtqNotified;
+
+    int rc = virtioCoreR3Init(pDevIns, &this->virtio, &pThisCC->virtio, &virtioPciParams, szInst.c_str(),
+                              FEATURES_OFFERED, 0, &this->gpuConfig, sizeof(gpuConfig));
+    AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+    pVirtioAdapter = std::make_unique<VirtioCoreVirtioAdapter>(&virtio);
+    AssertLogRelReturn(pVirtioAdapter != nullptr, VERR_NO_MEMORY);
+
+    return rc;
+}
+
+int VirtioGpuDevice::initializeVirtQueues()
+{
+    for (size_t uVirtqNbr {0u}; uVirtqNbr < virtioGpu::NUM_VIRTQUEUES; uVirtqNbr++) {
+        PVIRTIOGPU_VIRTQ pVirtq {&aVirtqs[uVirtqNbr]};
+        PVIRTIOGPU_WORKER pWorker {&aWorkers[uVirtqNbr]};
+
+        int rc = RTSemEventCreate(&pWorker->hEvent);
+        AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+        std::string sVirtqName {uVirtqNbr == virtioGpu::VirtqIdx::CONTROLQ ? std::string {"controlq"}
+                                                                           : std::string {"cursorq"}};
+        pVirtq->szName = sVirtqName;
+        pVirtq->uIdx = uVirtqNbr;
+        pWorker->uIdx = uVirtqNbr;
+    }
+    return VINF_SUCCESS;
+}
+
+int VirtioGpuDevice::initializeDisplay(uint32_t u32VRamSize, uint32_t u32MonitorCount)
+{
+    PPDMDEVINS pDevIns {virtio.pDevInsR3};
+
+    pDevIns->IBase.pfnQueryInterface = virtioGpuQueryInterface;
+    IBase.pfnQueryInterface = virtioGpuPortQueryInterface;
+    IPort.pfnUpdateDisplay = virtioGpuUpdateDisplay;
+
+    IPort.pfnUpdateDisplayAll = virtioGpuPortUpdateDisplayAll;
+    IPort.pfnQueryVideoMode = virtioGpuPortQueryVideoMode;
+    IPort.pfnSetRefreshRate = virtioGpuPortSetRefreshRate;
+    IPort.pfnTakeScreenshot = virtioGpuPortTakeScreenshot;
+    IPort.pfnFreeScreenshot = virtioGpuPortFreeScreenshot;
+    IPort.pfnDisplayBlt = virtioGpuPortDisplayBlt;
+    IPort.pfnUpdateDisplayRect = virtioGpuPortUpdateDisplayRect;
+    IPort.pfnCopyRect = virtioGpuPortCopyRect;
+    IPort.pfnSetRenderVRAM = virtioGpuPortSetRenderVRAM;
+    // used for SVGA only
+    IPort.pfnSetViewport = NULL;
+    IPort.pfnSendModeHint = vbvavirtioGpuPortSendModeHint;
+    IPort.pfnReportHostCursorCapabilities = vbvavirtioGpuPortReportHostCursorCapabilities;
+    IPort.pfnReportHostCursorPosition = vbvavirtioGpuPortReportHostCursorPosition;
+
+    IVirtioGpuPort.pfnDisplayChanged = virtioGpuDisplayChanged;
+
+    pDisplayManager =
+        std::make_unique<VirtioGpuDisplayManager>(pDevIns, 0 /*iLUN*/, IBase, u32VRamSize, u32MonitorCount);
+    AssertLogRelReturn(pDisplayManager != nullptr, VERR_NO_MEMORY);
+    return VINF_SUCCESS;
+}
+
+int VirtioGpuDevice::terminate(PPDMDEVINS)
+{
+    int rc {VINF_SUCCESS};
+
+    stop();
+    for (size_t uVirtqNbr {0u}; uVirtqNbr < virtioGpu::NUM_VIRTQUEUES; uVirtqNbr++) {
+        rc = RTSemEventDestroy(aWorkers[uVirtqNbr].hEvent);
+        AssertLogRelReturn(RT_SUCCESS(rc), rc);
+    }
+
+    pCmdHandler.reset();
+    pVirtioAdapter.reset();
+    pDisplayManager.reset();
+    pMemoryAdapter.reset();
+
+    return rc;
+}
+
+int VirtioGpuDevice::start()
+{
+    fNegotiatedFeatures = virtioCoreGetNegotiatedFeatures(&virtio);
+    return startVirtQueues();
+}
+
+int VirtioGpuDevice::stop()
+{
+    int rc {stopVirtQueues()};
+
+    gpuConfig.uEventsRead = 0;
+    gpuConfig.uEventsClear = 0;
+
+    pCmdHandler->clearResources();
+    return rc;
+}
+
+/*
+ * virtioMmioRead and virtioMmioWrite both return VINF_IOM_MMIO_UNUSED_00 in case
+ * of a bad access, thus we use this return value too.
+ */
+
+int VirtioGpuDevice::accessCap(uint32_t uOffset, std::function<void(uint32_t*)> accessFn)
+{
+    switch (uOffset) {
+    case 0: accessFn(&gpuConfig.uEventsRead); return VINF_SUCCESS;
+    case 4:
+        accessFn(&gpuConfig.uEventsClear);
+        /*
+         * uEventsRead has write-to-clear semantics, i.e. when the driver writes
+         * a bit to uEventsClear, we clear the bit in uEventsRead and clear uEventsClear
+         */
+        gpuConfig.uEventsRead &= ~gpuConfig.uEventsClear;
+        gpuConfig.uEventsClear = 0u;
+        return VINF_SUCCESS;
+    case 8: accessFn(&gpuConfig.uNumScanouts); return VINF_SUCCESS;
+    case 12: accessFn(&gpuConfig.uNumCapsets); return VINF_SUCCESS;
+    default:
+        LogRel(("%s: Invalid offset while accessing capabilties: %u\n", szInst.c_str(), uOffset));
+        return VINF_IOM_MMIO_UNUSED_00;
+    }
+}
+
+/*
+ * Virtio 1.2 - 4.1.3.1: For device configuration access, the driver MUST use [...]
+ * 32-bit wide and aligned accesses for 32-bit and 64-bit wide fields.
+ */
+int VirtioGpuDevice::readCap(uint32_t uOffset, void* pvBuf, uint32_t cbToRead)
+{
+    if (pvBuf == nullptr) {
+        LogRel(("%s: readCap: buffer to write to is a nullptr.\n", szInst.c_str()));
+        return VINF_IOM_MMIO_UNUSED_00;
+    }
+    if (cbToRead != sizeof(uint32_t)) {
+        LogRel(("%s: readCap: invalid access size. Tried to read %u bytes.\n", szInst.c_str(), cbToRead));
+        return VINF_IOM_MMIO_UNUSED_00;
+    }
+
+    std::function<void(uint32_t*)> accessFn = [pvBuf](uint32_t* pMember) { *static_cast<uint32_t*>(pvBuf) = *pMember; };
+
+    return accessCap(uOffset, accessFn);
+}
+
+int VirtioGpuDevice::writeCap(uint32_t uOffset, const void* pvBuf, uint32_t cbToWrite)
+{
+    if (pvBuf == nullptr) {
+        LogRel(("%s: writeCap: buffer to write to is a nullptr.\n", szInst.c_str()));
+        return VINF_IOM_MMIO_UNUSED_00;
+    }
+    if (cbToWrite != sizeof(uint32_t)) {
+        LogRel(("%s: writeCap: invalid access size. Tried to write %u bytes.\n", szInst.c_str(), cbToWrite));
+        return VINF_IOM_MMIO_UNUSED_00;
+    }
+    if (uOffset != 4) {
+        /* the driver is only allowed to write to uEventsClear */
+        LogRel(("%s: writeCap: invalid access: the driver may only write to offset 4 (offset was %u).\n",
+                szInst.c_str(), uOffset));
+        return VINF_IOM_MMIO_UNUSED_00;
+    }
+
+    std::function<void(uint32_t*)> accessFn = [pvBuf](uint32_t* pMember) {
+        *pMember = *static_cast<const uint32_t*>(pvBuf);
+    };
+
+    return accessCap(uOffset, accessFn);
+}
+
+void VirtioGpuDevice::displayChanged(uint32_t numDisplays, VMMDevDisplayDef* displayDefs)
+{
+    for (uint32_t i = 0; i < numDisplays; i++) {
+        bool enabled {not(displayDefs[i].fDisplayFlags & VMMDEV_DISPLAY_DISABLED)};
+
+        pCmdHandler->requestResize(i, enabled, displayDefs[i].cx, displayDefs[i].cy);
+    }
+
+    gpuConfig.uEventsRead |= virtioGpu::EVENT_DISPLAY;
+    LogRel5(("%s: device configuration has changed.\n", szInst.c_str()));
+
+    virtioCoreNotifyConfigChanged(&virtio);
+}
+
+void VirtioGpuDevice::wakeupWorker(uint16_t uVirtqNbr)
+{
+    if (uVirtqNbr != virtioGpu::VirtqIdx::CONTROLQ and uVirtqNbr != virtioGpu::VirtqIdx::CURSORQ) {
+        LogRel(("%s: tried to wake up unrecognized queue number: %d.\n", szInst.c_str(), uVirtqNbr));
+        return;
+    }
+
+    PVIRTIOGPU_WORKER pWorker {&aWorkers[uVirtqNbr]};
+
+    if (not ASMAtomicXchgBool(&pWorker->fNotified, true)) {
+        /*
+         * Two atomic variables to avoid (at least some) unnecessary signals.
+         * The fNotified variable should suffice to avoid lost signals.
+         */
+        if (ASMAtomicReadBool(&pWorker->fSleeping)) {
+            int rc {RTSemEventSignal(pWorker->hEvent)};
+            AssertRC(rc);
+        }
+    }
+}
+
+template <uint16_t uVirtqNbr>
+static DECLCALLBACK(int) virtQueueHandleFn(RTTHREAD /*hSelf*/, void* pvUser)
+{
+    PVIRTIOGPUDEV pThis {static_cast<PVIRTIOGPUDEV>(pvUser)};
+    return pThis->handleVirtQueue(uVirtqNbr);
+}
+
+auto controlQueueHandleFn {virtQueueHandleFn<virtioGpu::VirtqIdx::CONTROLQ>};
+auto cursorQueueHandleFn {virtQueueHandleFn<virtioGpu::VirtqIdx::CURSORQ>};
+
+int VirtioGpuDevice::startVirtQueues()
+{
+    fTerminateVirtQueues.store(false);
+
+    for (size_t uVirtqNbr {0u}; uVirtqNbr < virtioGpu::NUM_VIRTQUEUES; uVirtqNbr++) {
+        PVIRTIOGPU_VIRTQ pVirtq {&aVirtqs[uVirtqNbr]};
+        PVIRTIOGPU_WORKER pWorker {&aWorkers[uVirtqNbr]};
+
+        auto handlerFn = uVirtqNbr == virtioGpu::VirtqIdx::CONTROLQ ? controlQueueHandleFn : cursorQueueHandleFn;
+        int rc {RTThreadCreate(&pWorker->hThread, handlerFn, this, 0, RTTHREADTYPE_IO, RTTHREADFLAGS_WAITABLE,
+                               pVirtq->szName.c_str())};
+        AssertLogRelReturn(RT_SUCCESS(rc), rc);
+        pWorker->fAssigned = true;
+
+        rc = virtioCoreR3VirtqAttach(&virtio, pVirtq->uIdx, pVirtq->szName.c_str());
+        AssertLogRelReturn(RT_SUCCESS(rc), rc);
+        virtioCoreVirtqEnableNotify(&virtio, pVirtq->uIdx, true);
+        pVirtq->fAttachedToVirtioCore = true;
+    }
+
+    return VINF_SUCCESS;
+}
+
+int VirtioGpuDevice::stopVirtQueues()
+{
+    fTerminateVirtQueues.store(true);
+
+    for (size_t uVirtqNbr {0u}; uVirtqNbr < virtioGpu::NUM_VIRTQUEUES; uVirtqNbr++) {
+        PVIRTIOGPU_VIRTQ pVirtq {&aVirtqs[uVirtqNbr]};
+        PVIRTIOGPU_WORKER pWorker {&aWorkers[uVirtqNbr]};
+
+        if (not pWorker->fAssigned) {
+            continue;
+        }
+
+        int rc = RTSemEventSignal(pWorker->hEvent);
+        AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+        rc = RTThreadWaitNoResume(pWorker->hThread, RT_INDEFINITE_WAIT, nullptr);
+        AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+        pWorker->fAssigned = false;
+        pVirtq->fAttachedToVirtioCore = false;
+    }
+
+    return VINF_SUCCESS;
+}
+
+int VirtioGpuDevice::handleVirtQueue(uint16_t uVirtqNbr)
+{
+    PVIRTIOGPU_VIRTQ pVirtq {&aVirtqs[uVirtqNbr]};
+    PVIRTIOGPU_WORKER pWorker {&aWorkers[uVirtqNbr]};
+    PPDMDEVINS pDevIns {virtio.pDevInsR3};
+
+    LogRel2(("%s: worker thread %d started for %s (virtq idx=%d).\n", szInst.c_str(), pWorker->uIdx,
+             pVirtq->szName.c_str(), pVirtq->uIdx));
+
+    auto is_virtq_empty = [this, &pDevIns, uVirtqNbr]() -> bool {
+        return virtioCoreVirtqAvailBufCount(pDevIns, &virtio, uVirtqNbr) == 0;
+    };
+
+    while (not fTerminateVirtQueues.load()) {
+        if (is_virtq_empty()) {
+            /*
+             * Two atomic variables to avoid (at least some) unnecessary signals.
+             * The fNotified variable should suffice to avoid lost signals.
+             */
+            ASMAtomicWriteBool(&pWorker->fSleeping, true);
+            if (not ASMAtomicXchgBool(&pWorker->fNotified, false)) {
+                int rc {RTSemEventWait(pWorker->hEvent, RT_INDEFINITE_WAIT)};
+                AssertLogRelReturn(RT_SUCCESS(rc) or rc == VERR_INTERRUPTED, rc);
+
+                if (rc == VERR_INTERRUPTED) {
+                    continue;
+                }
+
+                ASMAtomicWriteBool(&pWorker->fNotified, false);
+            }
+            ASMAtomicWriteBool(&pWorker->fSleeping, false);
+        }
+
+        if (RT_UNLIKELY(fTerminateVirtQueues.load())) {
+            break;
+        }
+
+        if (is_virtq_empty()) {
+            /*
+             * It may happen that we got an unnecessary signal, thus we double-check
+             * wether the virtq is empty.
+             */
+            continue;
+        }
+
+#ifdef VIRTIO_VBUF_ON_STACK
+        PVIRTQBUF pVirtqBuf = virtioCoreR3VirtqBufAlloc();
+        if (!pVirtqBuf) {
+            LogRel(("Failed to allocate memory for VIRTQBUF\n"));
+            break; /* No point in trying to allocate memory for other descriptor
+                      chains */
+        }
+        int rc {virtioCoreR3VirtqAvailBufGet(pDevIns, &virtio, pVirtq->uIdx, pVirtqBuf, true)};
+#else
+        // The virtq is not empty, we take a buffer from it and handle it.
+        PVIRTQBUF pVirtqBuf {nullptr};
+        int rc {virtioCoreR3VirtqAvailBufGet(pDevIns, &virtio, pVirtq->uIdx, &pVirtqBuf, true)};
+#endif
+
+        if (rc == VERR_NOT_AVAILABLE) {
+            continue;
+        }
+
+        pCmdHandler->handleBuffer(pVirtqBuf);
+        virtioCoreR3VirtqBufRelease(&virtio, pVirtqBuf);
+    }
+
+    return VINF_SUCCESS;
+}
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpu.hpp b/src/VBox/Devices/Graphics/DevVirtioGpu.hpp
new file mode 100644
index 0000000000..72474ed6eb
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpu.hpp
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#pragma once
+
+#include <iprt/mem.h>
+
+#include <VBox/vmm/pdmapi.h>
+#include <VBox/vmm/pdmdev.h>
+#include <VBox/vmm/vm.h>
+
+#include "../VirtIO/VirtioCore.h"
+#include "DevVirtioGpuDefinitions.hpp"
+#include "DevVirtioGpuDisplayManager.hpp"
+#include "DevVirtioGpuCmdHandler.hpp"
+#include "DevVirtioGpuResource.hpp"
+
+#include <atomic>
+#include <cstdint>
+#include <functional>
+#include <memory>
+#include <string>
+
+class VirtioCoreVirtioAdapter;
+class VirtioGpuMemoryAdapter;
+
+/**
+ * Logging-Level rules for anything inside LOG_GROUP_DEV_VIRTIO_GPU:
+ *   LogRel  - conditions that lead to functions returning early or returning anything other than VINF_SUCCESS
+ *   LogRel2 - logging of things that should only happen once or very few, e.g. creation of a queue or taking over the
+ * driver LogRel5 - informative logging from the virtio-gpu (only DevVirtioGpu.hpp and DevVirtioGpu.cpp, but not the
+ * adapters) LogRel6 - informative logging from any adapter LogRel7 - informative logging from the cmd-handler LogRel8 -
+ * informative logging inside the VBox-Stubs (DevVirtioGpuVBoxStubs.hpp and DevVirtioGpuVBoxStubs.cpp)
+ *
+ * Enabling logging levels 1 and 2 shouldn't lead to too much output (common sense applies), while the other logging
+ * levels may lead to a lot of output.
+ *
+ * If you have access to VirtioGpuDevice::szInst, start your messages with ("%s: ...", virtioGpuDevice.szInst.c_str()).
+ * Otherwise start your messages with a prefix for easy grepping.
+ *
+ * Enable logging for only the virtio-gpu with: 'export VBOX_RELEASE_LOG="-all+dev_virtio_gpu.e.lA.lB" where A and B are
+ * the desired logging levels. You can of course add more logging levels with ".lC.lD...". ".e" automatically enables
+ * logging level 1, i.e. LogRel.
+ *
+ */
+
+class VirtioGpuDevice
+{
+    static constexpr uint16_t FEATURES_OFFERED {virtioGpu::Features::EDID}; ///< The features offered to the guest
+                                                                            ///
+public:
+    /**
+     * Initialize the Virtio GPU
+     *
+     * \param pDevIns The PCI Device Instance
+     * \param iInstance The instance number.
+     * \param u32VRamSize The size of the VRam.
+     * \param cMonitorCount The amount of displays configured for the VM.
+     * \param secondaryController True if this is a secondary graphics controller, e.g. if the active graphics
+     * controller is VGAWithVirtioGpu, false if this is the only graphics controller.
+     *
+     * \return VBox status code
+     */
+    int init(PPDMDEVINS pDevIns, int iInstance, uint32_t u32VRamSize, uint32_t cMonitorCount, bool secondaryController);
+
+    /**
+     * Terminates the Virtio GPU.
+     *
+     * \param pDevIns The PCI Device Instance
+     *
+     * \return VBox status code
+     */
+    int terminate(PPDMDEVINS pDevIns);
+
+    /**
+     * Start the Virtio GPU. This function is called when the driver calls
+     * pfnStatusChanged with fDriverOk != 0.
+     *
+     * \return VBox Status Code
+     */
+    int start();
+
+    /**
+     * Stop the Virtio GPU. This function is called when the driver calls
+     * pfnStatusChanged with fDriverOk == 0.
+     *
+     * \return VBox Status Code
+     */
+    int stop();
+
+    /**
+     * Read from the device-specific configuration.
+     *
+     * \param uOffset The offset into the device-specific configuration
+     * \param pvBuf The buffer in which to save the read data
+     * \param cbToRead The number of bytes to read
+     *
+     * \return VBox Status Code
+     */
+    int readCap(uint32_t uOffset, void* pvBuf, uint32_t cbToRead);
+
+    /**
+     * Write to the device-specific configuration.
+     *
+     * \param uOffset The offset into the device-specific configuration
+     * \param pvBuf The buffer with the bytes to write
+     * \param cbToWrite The number of bytes to write
+     *
+     * \return VBox Status Code
+     */
+    int writeCap(uint32_t uOffset, const void* pvBuf, uint32_t cbToWrite);
+
+    /**
+     * Informs the worker of a virtqueue that it has new buffers.
+     *
+     * \param uVirtqNbr The number of the virtqueue that has new buffers.
+     */
+    void wakeupWorker(uint16_t uVirtqNbr);
+
+    /**
+     * The handler function for the virtqueues.
+     *
+     * \param uVirtqNbr The index of the associcated virtqueue
+     * \param pDevIns The PCI Device Instance
+     *
+     * \return VBox status code
+     */
+    int handleVirtQueue(uint16_t uVirtqNbr);
+
+private:
+    /**
+     * Initialize the Virtio-Core part of the Virtio GPU
+     *
+     * \param pDevIns The PCI Device Instance
+     *
+     * \return VBox status code
+     */
+    int initializeVirtio(PPDMDEVINS pDevIns);
+
+    /**
+     * Initialize the virtqueues, but do NOT start them.
+     *
+     * \return VBox status code.
+     */
+    int initializeVirtQueues();
+
+    /**
+     * Initializes the display, i.e. assigns functions to the driver etc.
+     *
+     * \param u32VRamSize The size of the VRam
+     * \param u32MonitorCount The maximum of attachable monitors
+     *
+     * \return VBox status code.
+     */
+    int initializeDisplay(uint32_t u32VRamSize, uint32_t u32MonitorCount);
+
+    /**
+     * Start the virtqueues, i.e. start the worker-threads and attach the
+     * virtqueues to virtio core.
+     *
+     * \return VBox status code
+     */
+    int startVirtQueues();
+
+    /**
+     * Stop the virtqueues, i.e. stop the worker-threads.
+     *
+     * \return VBox status code
+     */
+    int stopVirtQueues();
+
+    /**
+     * Accesses the device-specific configuration at the given offset using the
+     * given function.
+     *
+     * \param uOffset The offset into the device-specific configuration
+     * \param accessFn The function that is used to access the device-specific configuration
+     *
+     * \return VBox status code
+     */
+    int accessCap(uint32_t uOffset, std::function<void(uint32_t*)> accessFn);
+
+public:
+    /* device-specific queue info */
+    typedef struct VirtioGpuVirtQueue
+    {
+        uint16_t uIdx; ///< The index of this virtqueue
+        uint16_t uPadding;
+        std::string szName;         ///< The name of this virtqueue
+        bool fHasWorker;            ///< If set this virtqueue has an associated worker
+        bool fAttachedToVirtioCore; ///< If set this virtqueue is attached to virtio core
+    } VIRTIOGPU_VIRTQ, *PVIRTIOGPU_VIRTQ;
+
+    /* a worker thread of a virtqueue */
+    typedef struct VirtioGpuWorker
+    {
+        RTSEMEVENT hEvent;       ///< The handle of the associated sleep/wake-up semaphore
+        RTTHREAD hThread;        ///< The handle of the associated worker-thread
+        uint16_t uIdx;           ///< The index of this worker (should be the same as the index of the associated virtq)
+        bool volatile fSleeping; ///< If set this thread is sleeping
+        bool volatile fNotified; ///< If set this thread has been notified that there is work to do
+        bool fAssigned;          ///< If set this thread has been set up
+    } VIRTIOGPU_WORKER, *PVIRTIOGPU_WORKER;
+
+public:
+    /* virtio core requires that members are public.*/
+    VIRTIOCORE virtio;           // core virtio state
+    virtioGpu::Config gpuConfig; // device specific configuration of the virtio GPU
+
+    VirtioGpuVirtQueue aVirtqs[virtioGpu::NUM_VIRTQUEUES];
+    VirtioGpuWorker aWorkers[virtioGpu::NUM_VIRTQUEUES];
+    std::atomic<bool> fTerminateVirtQueues;
+
+    std::string szInst; // instance name
+
+    uint64_t fNegotiatedFeatures; // features negotiated with the guest
+
+    /* The commands send by the driver are handled by the VirtioGpuCmdHandler. To be able
+     * to test this class using unit-tests, the handler needs a few adapters to be able to control
+     * how pages are mapped, displays are handled and the commands are read.
+     */
+    std::unique_ptr<VirtioGpuCmdHandler> pCmdHandler;
+    std::unique_ptr<VirtioCoreVirtioAdapter> pVirtioAdapter;
+    std::unique_ptr<VirtioGpuDisplayManager> pDisplayManager;
+    std::unique_ptr<VirtioGpuMemoryAdapter> pMemoryAdapter;
+
+public:
+    PDMIBASE IBase;
+    PDMIDISPLAYPORT IPort;
+    PDMIDISPLAYVBVACALLBACKS IVBVACallbacks;
+    PDMIVIRTIOGPUPORT IVirtioGpuPort;
+
+    /**
+     * Signals to the driver that the resolution or the monitor status
+     * (enabled, disabled) has changed.
+     *
+     * \param numDisplays Number of displays available
+     * \param displayDefs Array of display definitions describing the
+     *                    configuration of each display
+     */
+    void displayChanged(uint32_t numDisplays, VMMDevDisplayDef* displayDefs);
+
+    /**
+     * Attaches the Virtio-GPU to the VBox-window.
+     *
+     * \param iLUN The LUN to attach to. This must be 0.
+     *
+     * \return VBox status code
+     */
+    int attachDisplay(unsigned iLUN);
+
+    /**
+     * Detaches the Virtio-GPU driver.
+     *
+     * \param iLUN The LUN to detach from.
+     */
+    void detachDisplay(unsigned iLUN);
+};
+
+/**
+ *  VirtioCore needs a separate class that holds the R3 state
+ */
+class VirtioGpuDeviceR3
+{
+public:
+    VIRTIOCORER3 virtio; // core virtio state R3
+};
+
+typedef VirtioGpuDevice VIRTIOGPUDEV;
+typedef VIRTIOGPUDEV* PVIRTIOGPUDEV;
+
+typedef VirtioGpuDeviceR3 VIRTIOGPUDEVCC;
+typedef VIRTIOGPUDEVCC* PVIRTIOGPUDEVCC;
+
+class VirtioCoreVirtioAdapter final : public VirtioGpuCmdHandler::VirtioAdapter
+{
+    PVIRTIOCORE pVirtio_ {nullptr};
+
+public:
+    VirtioCoreVirtioAdapter() = delete;
+    VirtioCoreVirtioAdapter(PVIRTIOCORE pVirtio) : pVirtio_(pVirtio) {}
+
+    void virtqBufDrain(PVIRTQBUF pVirtqBuf, void* pv, size_t cb) final
+    {
+        virtioCoreR3VirtqBufDrain(pVirtio_, pVirtqBuf, pv, cb);
+    }
+
+    void virtqBufPut(PVIRTQBUF pVirtqBuf, void* pv, size_t cb) final
+    {
+        PRTSGSEG pReturnSeg = static_cast<PRTSGSEG>(RTMemAllocZ(sizeof(RTSGSEG)));
+        AssertReleaseMsg(pReturnSeg != nullptr, ("Out of memory"));
+
+        pReturnSeg->pvSeg = RTMemAllocZ(cb);
+        AssertReleaseMsg(pReturnSeg->pvSeg != nullptr, ("Out of memory"));
+        memcpy(pReturnSeg->pvSeg, pv, cb);
+        pReturnSeg->cbSeg = cb;
+
+        PRTSGBUF pReturnSegBuf = static_cast<PRTSGBUF>(RTMemAllocZ(sizeof(RTSGBUF)));
+        AssertReleaseMsg(pReturnSegBuf, ("Out of memory"));
+
+        RTSgBufInit(pReturnSegBuf, pReturnSeg, 1);
+
+        virtioCoreR3VirtqUsedBufPut(pVirtio_->pDevInsR3, pVirtio_, pVirtqBuf->uVirtq, pReturnSegBuf, pVirtqBuf,
+                                    true /* fFence */);
+
+        RTMemFree(pReturnSeg->pvSeg);
+        RTMemFree(pReturnSeg);
+        RTMemFree(pReturnSegBuf);
+    }
+
+    void virtqSyncRings(PVIRTQBUF pVirtqBuf) final
+    {
+        virtioCoreVirtqUsedRingSync(pVirtio_->pDevInsR3, pVirtio_, pVirtqBuf->uVirtq);
+    }
+};
+
+class VirtioGpuMemoryAdapter final : public VirtioGpuCmdHandler::MemoryAdapter
+{
+    PPDMDEVINS pDevIns_ {nullptr};
+
+public:
+    VirtioGpuMemoryAdapter() = delete;
+    VirtioGpuMemoryAdapter(PPDMDEVINS pDevIns) : pDevIns_(pDevIns) {}
+
+    VecMappings mapGCPhys2HCVirt(const VecMemEntries& vBacking)
+    {
+        VecMappings vMapping;
+        vMapping.reserve(vBacking.size());
+
+        for (const auto& backing : vBacking) {
+            size_t currSize {backing.uLength_};
+            /*
+             * PDMDevHlpPhysGCPhys2CCPtr always maps exactly one page, thus it may
+             * happen that we need multiple mappings for one backing-entry
+             */
+            while (currSize != 0) {
+                PPGMPAGEMAPLOCK pLock {new PGMPAGEMAPLOCK};
+                void* vAddr {nullptr};
+                int rc {PDMDevHlpPhysGCPhys2CCPtr(pDevIns_, backing.uAddr_, 0, &vAddr, pLock)};
+                AssertRC(rc);
+                vMapping.emplace_back(vAddr, PAGE_SIZE, pLock);
+                currSize -= PAGE_SIZE;
+            }
+        }
+
+        return vMapping;
+    }
+
+    void releaseMappings(const VecMappings& vMapping)
+    {
+        for (const auto& mapping : vMapping) {
+            PPGMPAGEMAPLOCK pLock {reinterpret_cast<PPGMPAGEMAPLOCK>(mapping.pv_)};
+            PDMDevHlpPhysReleasePageMappingLock(pDevIns_, pLock);
+            delete pLock;
+        }
+    }
+};
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpuCmdHandler.cpp b/src/VBox/Devices/Graphics/DevVirtioGpuCmdHandler.cpp
new file mode 100644
index 0000000000..4db05af5b7
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpuCmdHandler.cpp
@@ -0,0 +1,687 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#define LOG_GROUP LOG_GROUP_DEV_VIRTIO_GPU
+#include "DevVirtioGpuCmdHandler.hpp"
+
+#include <iprt/assert.h>
+
+#include <VBox/log.h>
+#include <VBox/types.h>
+
+#include <cyberus/edid.hpp>
+
+#include <algorithm>
+#include <cstring>
+
+VirtioGpuCmdHandler::VirtioGpuCmdHandler(VirtioAdapter& vAdapter, DisplayManager& dManager, MemoryAdapter& mAdapter,
+                                         uint32_t numScanouts, bool attachDisplayLater)
+    : virtioAdapter_(vAdapter), displayManager_(dManager), memoryAdapter_(mAdapter), numScanouts_(numScanouts)
+{
+    for (unsigned currentScanout {0u}; currentScanout < numScanouts_; currentScanout++) {
+        Scanout scanout {displayManager_};
+        scanout.uScanoutId = currentScanout;
+
+        /* if this is the only graphics controller we want to attach immediately to the display. */
+        if (not attachDisplayLater and scanout.hasDisplay() and not scanout.isAttachedToDisplay()) {
+            scanout.attachDisplay();
+        }
+
+        if (scanout.hasDisplay()) {
+            auto [uWidth, uHeight] = scanout.isAttachedToDisplay() ? scanout.displayDimensions() : getDummySize();
+            scanout.uCurrentWidth = uWidth;
+            scanout.uCurrentHeight = uHeight;
+        }
+
+        activeScanouts.push_back(scanout);
+    }
+
+    LogRel2(("virtio-gpu cmd handler: created. Num of scanouts is %u.\n", activeScanouts.size()));
+}
+
+inline bool VirtioGpuCmdHandler::scanoutExists(uint32_t uScanout)
+{
+    return uScanout <= numScanouts_ - 1;
+}
+
+inline std::optional<VirtioGpuCmdHandler::ScanoutRef> VirtioGpuCmdHandler::getScanout(uint32_t uScanout)
+{
+    if (not scanoutExists(uScanout)) {
+        return {};
+    }
+
+    return activeScanouts.at(uScanout);
+}
+
+inline std::vector<VirtioGpuCmdHandler::ScanoutRef> VirtioGpuCmdHandler::getScanoutsByResource(uint32_t uResourceId)
+{
+    std::vector<ScanoutRef> results;
+    for (auto& scanout : activeScanouts) {
+        if (not(scanout.uResourceId == uResourceId)) {
+            continue;
+        }
+
+        results.emplace_back(std::ref(scanout));
+    }
+
+    return results;
+}
+
+std::optional<VirtioGpuCmdHandler::ScanoutCRef> VirtioGpuCmdHandler::getCScanout(uint32_t uScanout)
+{
+    auto maybeScanout {getScanout(uScanout)};
+
+    if (not maybeScanout.has_value()) {
+        return {};
+    }
+
+    return {std::cref(maybeScanout->get())};
+}
+
+void VirtioGpuCmdHandler::requestResize(uint32_t uScanout, bool enabled, uint32_t uWidth, uint32_t uHeight)
+{
+    auto maybeScanout {getScanout(uScanout)};
+    if (not maybeScanout.has_value()) {
+        LogRel(("virtio-gpu cmd handler: Scanout %d not available\n", uScanout));
+        return;
+    }
+
+    auto& currentScanout {maybeScanout->get()};
+
+    currentScanout.fActive = enabled;
+    if (!enabled) {
+        currentScanout.detachDisplay();
+    }
+
+    currentScanout.uResizedWidth = uWidth;
+    currentScanout.uResizedHeight = uHeight;
+    currentScanout.fResizeRequested = true;
+}
+
+inline void VirtioGpuCmdHandler::resizeScanout(uint32_t uScanout, uint32_t uWidth, uint32_t uHeight)
+{
+    auto maybeScanout {getScanout(uScanout)};
+    if (not maybeScanout.has_value()) {
+        return;
+    }
+
+    auto& currentScanout {maybeScanout->get()};
+    if (uWidth != currentScanout.uCurrentWidth or uHeight != currentScanout.uCurrentHeight
+        or currentScanout.fNeedsResize) {
+        currentScanout.uCurrentWidth = uWidth;
+        currentScanout.uCurrentHeight = uHeight;
+
+        if (currentScanout.isAttachedToDisplay()) {
+            currentScanout.fNeedsResize = false;
+            currentScanout.resizeDisplay();
+        }
+    }
+}
+
+inline VirtioGpuResource* VirtioGpuCmdHandler::getResource(uint32_t uResourceId)
+{
+    auto result {std::find_if(std::begin(vResources_), std::end(vResources_),
+                              [uResourceId](const auto& it) { return uResourceId == it->resourceId(); })};
+
+    return result == std::end(vResources_) ? nullptr : result->get();
+}
+
+inline bool VirtioGpuCmdHandler::createResource(uint32_t uResourceId)
+{
+    if (getResource(uResourceId) != nullptr) {
+        return false;
+    }
+
+    vResources_.emplace_back(new VirtioGpuResource(uResourceId));
+    return true;
+}
+
+inline void VirtioGpuCmdHandler::removeResource(uint32_t uResourceId)
+{
+    auto result {std::find_if(std::begin(vResources_), std::end(vResources_),
+                              [uResourceId](const auto& it) { return uResourceId == it->resourceId(); })};
+
+    if (result != std::end(vResources_)) {
+        vResources_.erase(result);
+    }
+
+    auto scanouts {getScanoutsByResource(uResourceId)};
+    for (auto& scanout : scanouts) {
+        scanout.get().uResourceId = 0;
+    }
+}
+
+void VirtioGpuCmdHandler::handleBuffer(PVIRTQBUF pVirtqBuf)
+{
+    if (pVirtqBuf->cbPhysSend < sizeof(virtioGpu::CtrlHdr)) {
+        LogRel(("virtio-gpu cmd handler: handleBuffer: request buffer of command in virtq %u too small\n",
+                pVirtqBuf->uVirtq));
+        returnResponseNoData(pVirtqBuf, nullptr, virtioGpu::CtrlType::Response::ERR_OUT_OF_MEMORY);
+        return;
+    }
+
+    /*
+     * This lock is a precaution to avoid race conditions. If done right, there are never more than two threads calling
+     * this function, and those two threads shouldn't interfere even if they call this function at the same time.
+     */
+    RTCLock guard(mutex_);
+
+    virtioGpu::CtrlHdr hdr;
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, &hdr, sizeof(hdr));
+
+    switch (static_cast<virtioGpu::CtrlType::Cmd>(hdr.uType)) {
+    case virtioGpu::CtrlType::Cmd::GET_DISPLAY_INFO: cmdGetDisplayInfo(pVirtqBuf, &hdr); break;
+    case virtioGpu::CtrlType::Cmd::GET_EDID: cmdGetEdid(pVirtqBuf, &hdr); break;
+    case virtioGpu::CtrlType::Cmd::RESOURCE_CREATE_2D: cmdResourceCreate2d(pVirtqBuf, &hdr); break;
+    case virtioGpu::CtrlType::Cmd::RESOURCE_UNREF: cmdResourceUnref(pVirtqBuf, &hdr); break;
+    case virtioGpu::CtrlType::Cmd::SET_SCANOUT: cmdSetScanout(pVirtqBuf, &hdr); break;
+    case virtioGpu::CtrlType::Cmd::RESOURCE_FLUSH: cmdResourceFlush(pVirtqBuf, &hdr); break;
+    case virtioGpu::CtrlType::Cmd::TRANSFER_TO_HOST_2D: cmdTransferToHost2d(pVirtqBuf, &hdr); break;
+    case virtioGpu::CtrlType::Cmd::RESOURCE_ATTACH_BACKING: cmdResourceAttachBacking(pVirtqBuf, &hdr); break;
+    case virtioGpu::CtrlType::Cmd::RESOURCE_DETACH_BACKING: cmdResourceDetachBacking(pVirtqBuf, &hdr); break;
+    case virtioGpu::CtrlType::Cmd::UPDATE_CURSOR:
+    case virtioGpu::CtrlType::Cmd::MOVE_CURSOR:
+        if (pVirtqBuf->uVirtq != virtioGpu::VirtqIdx::CURSORQ) {
+            /*
+             * Not sure wether ERR_UNSPEC is the right thing here, but this is
+             * also an odd error.
+             */
+            returnResponseNoData(pVirtqBuf, &hdr, virtioGpu::CtrlType::Response::ERR_UNSPEC);
+        } else {
+            returnResponseNoData(pVirtqBuf, &hdr, virtioGpu::CtrlType::Response::OK_NODATA);
+        }
+        break;
+    default:
+        returnResponseNoData(pVirtqBuf, &hdr, virtioGpu::CtrlType::Response::ERR_UNSPEC);
+        LogRel(("virtio-gpu cmd handler: handleBuffer: got an unrecognized command in virtq %u: %#x\n",
+                pVirtqBuf->uVirtq, hdr.uType));
+    }
+}
+
+inline bool VirtioGpuCmdHandler::checkCtrlqCmd(const char* cmdName, PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr,
+                                               size_t cbSend, size_t cbReturn)
+{
+    /*
+     * we subtract sizeof(virtioGpu::CtrlHdr) from cbSend, because we want to know
+     * wether we are able to drain to payload of a given command from pVirtqBuf.
+     * That way we can write e.g. sizeof(virtioGpu::getEdid) as the fourth argument,
+     * instead of writing sizeof(virtioGpu::getEdid) - sizeof(virtioGpu::CtrlHdr)
+     * every time
+     */
+    cbSend = cbSend == 0 ? 0 : cbSend - sizeof(virtioGpu::CtrlHdr);
+
+    if (pVirtqBuf->uVirtq != virtioGpu::VirtqIdx::CONTROLQ) {
+        LogRel(("virtio-gpu cmd handler: %s: command was in the wrong virtq.\n", cmdName));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_UNSPEC);
+        return false;
+    }
+
+    if (cbSend > 0 and pVirtqBuf->cbPhysSend < cbSend) {
+        LogRel(("virtio-gpu cmd handler: %s: request buffer was too small.\n", cmdName));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_OUT_OF_MEMORY);
+        return false;
+    }
+
+    if (cbReturn > 0 and pVirtqBuf->cbPhysReturn < cbReturn) {
+        LogRel(("virtio-gpu cmd handler: %s: response buffer was too small.\n", cmdName));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_OUT_OF_MEMORY);
+        return false;
+    }
+
+    return true;
+}
+
+inline bool VirtioGpuCmdHandler::checkScanoutId(const char* cmdName, PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr,
+                                                uint32_t uScanoutId)
+{
+    auto maybeScanout {getScanout(uScanoutId)};
+    if (not maybeScanout.has_value()) {
+        LogRel(("virtio-gpu cmd handler: %s: unknown scanout id %u\n", cmdName, uScanoutId));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_INVALID_SCANOUT_ID);
+        return false;
+    }
+
+    auto& currentScanout {maybeScanout->get()};
+    if (not currentScanout.hasDisplay()) {
+        LogRel(("virtio-gpu cmd handler: %s: scanout %u has no display.\n", cmdName, uScanoutId));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_INVALID_SCANOUT_ID);
+        return false;
+    }
+
+    return true;
+}
+
+inline bool VirtioGpuCmdHandler::checkResourceId(const char* cmdName, PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr,
+                                                 uint32_t uResourceId)
+{
+    if (getResource(uResourceId) == nullptr) {
+        LogRel(("virtio-gpu cmd handler: %s: resource id %u does not exist.\n", cmdName, uResourceId));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_INVALID_RESOURCE_ID);
+        return false;
+    }
+    return true;
+}
+
+inline void VirtioGpuCmdHandler::returnResponseOkEarly(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not pCtrlHdr->has_flag(virtioGpu::CtrlHdr::Flags::FENCE)) {
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::OK_NODATA);
+    }
+}
+
+inline void VirtioGpuCmdHandler::returnResponseOkLate(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (pCtrlHdr->has_flag(virtioGpu::CtrlHdr::Flags::FENCE)) {
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::OK_NODATA);
+    }
+}
+
+inline void VirtioGpuCmdHandler::returnResponseNoData(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr,
+                                                      virtioGpu::CtrlType::Response responseType)
+{
+    if (pVirtqBuf->cbPhysReturn < sizeof(virtioGpu::CtrlHdr)) {
+        return;
+    }
+
+    virtioGpu::CtrlHdr response {responseType};
+
+    if (pCtrlHdr != nullptr) {
+        /*
+         * It may happen that the caller of this functions passes a nullptr if
+         * the request buffer of pVirtqBuf is too small for a header.
+         */
+        response.transfer_fence(pCtrlHdr);
+    }
+
+    returnResponseBuf(pVirtqBuf, &response, sizeof(virtioGpu::CtrlHdr));
+}
+
+inline void VirtioGpuCmdHandler::returnResponseBuf(PVIRTQBUF pVirtqBuf, void* pv, size_t cb)
+{
+    virtioAdapter_.virtqBufPut(pVirtqBuf, pv, cb);
+    virtioAdapter_.virtqSyncRings(pVirtqBuf);
+}
+
+void VirtioGpuCmdHandler::cmdGetDisplayInfo(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not checkCtrlqCmd("GetDisplayInfo", pVirtqBuf, pCtrlHdr, 0,
+                          virtioGpu::ResponseDisplayInfo::size(numScanouts_))) {
+        return;
+    }
+
+    LogRel7(("virtio-gpu cmd handler: Got GET_DISPLAY_INFO command.\n"));
+    virtioGpu::ResponseDisplayInfo response;
+
+    for (unsigned i {0}; i < numScanouts_; i++) {
+        auto& pmode {response.pmodes[i]};
+        if (scanoutExists(i)) {
+            auto& currentScanout {getScanout(i)->get()};
+
+            /*
+             * Here we should only report scanouts that are already attached to a
+             * display. But this doesn't work if a driver is started later, because
+             * then it wouldn't see any scanouts.
+             */
+            if (not currentScanout.hasDisplay()) {
+                LogRel7(("virtio-gpu cmd handler: Scanout %u has no display.\n", i));
+                continue;
+            }
+
+            if (currentScanout.fResizeRequested) {
+                resizeScanout(i, currentScanout.uResizedWidth, currentScanout.uResizedHeight);
+                currentScanout.fResizeRequested = false;
+            }
+
+            pmode.r.width = currentScanout.uCurrentWidth;
+            pmode.r.height = currentScanout.uCurrentHeight;
+
+            pmode.enabled = currentScanout.fActive;
+
+            continue;
+        }
+    }
+
+    returnResponseBuf(pVirtqBuf, &response, virtioGpu::ResponseDisplayInfo::size(numScanouts_));
+}
+
+template <typename VIRTIO_GPU_CMD>
+static size_t sizeofPayload(VIRTIO_GPU_CMD cmd)
+{
+    return sizeof(cmd) - sizeof(virtioGpu::CtrlHdr);
+}
+
+void VirtioGpuCmdHandler::cmdGetEdid(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not checkCtrlqCmd("GetEdid", pVirtqBuf, pCtrlHdr, sizeof(virtioGpu::GetEdid),
+                          sizeof(virtioGpu::ResponseEdid))) {
+        return;
+    }
+
+    virtioGpu::GetEdid request;
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, request.payload(), sizeofPayload(request));
+    LogRel7(("virtio-gpu cmd handler: Got GET_EDID command for scanout %u.\n", request.uScanout));
+
+    if (not checkScanoutId("GetEdid", pVirtqBuf, pCtrlHdr, request.uScanout)) {
+        return;
+    }
+
+    virtioGpu::ResponseEdid response;
+
+    auto& currentScanout {getScanout(request.uScanout)->get()};
+    if (currentScanout.fResizeRequested) {
+        resizeScanout(0, currentScanout.uResizedWidth, currentScanout.uResizedHeight);
+        currentScanout.fResizeRequested = false;
+    }
+
+    auto edid {generateExtendedEdid(currentScanout.uResizedWidth, currentScanout.uResizedHeight)};
+    AssertReleaseMsg(sizeof(edid) <= sizeof(response.aEdid),
+                     ("virtio-gpu cmd handler: GetEdid: Given EDID is too big to be returned to the driver!"));
+    response.uSize = std::min(sizeof(edid), sizeof(response.aEdid));
+    std::memcpy(&response.aEdid, &edid, response.uSize);
+
+    returnResponseBuf(pVirtqBuf, &response, sizeof(virtioGpu::ResponseEdid));
+}
+
+void VirtioGpuCmdHandler::cmdResourceCreate2d(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not checkCtrlqCmd("ResourceCreate2D", pVirtqBuf, pCtrlHdr, sizeof(virtioGpu::ResourceCreate2d),
+                          sizeof(virtioGpu::CtrlHdr))) {
+        return;
+    }
+
+    virtioGpu::ResourceCreate2d request;
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, request.payload(), sizeofPayload(request));
+    LogRel7(("virtio-gpu cmd handler: Got RESOURCE_CREATE_2D command. (resource=%u, format=%u, width=%u, height=%u)\n",
+             request.uResourceId, request.uFormat, request.uWidth, request.uHeight));
+
+    if (request.uResourceId == 0) {
+        /*
+         * The driver can disable a scanout in SET_SCANOUT by setting uResourceId to 0. Thus
+         * (even though the specification doesn't say anything about this) we disallow creating
+         * resources with an Id of 0 here.
+         */
+        LogRel(("virtio-gpu cmd handler: ResourceCreate2D: resource id %u can not be used.\n", request.uResourceId));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_INVALID_RESOURCE_ID);
+        return;
+    }
+
+    if (not createResource(request.uResourceId)) {
+        LogRel(("virtio-gpu cmd handler: ResourceCreate2D: resource id %u already in use.\n", request.uResourceId));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_INVALID_RESOURCE_ID);
+        return;
+    }
+
+    /* We currently only support the B8G8R8X8_UNORM pixel format. Thus, in case
+     * the driver uses another format, we print a message to the log.
+     * For some reason, the customers driver uses the B8G8R8A8_UNORM in the first
+     * resource it creates. Thus this format has to be enabled too.
+     */
+    if ((request.uFormat & (virtioGpu::Format::B8G8R8A8_UNORM | virtioGpu::Format::B8G8R8X8_UNORM)) == 0) {
+        LogRel(("virtio-gpu cmd handler: ResourceCreate2D: An unsupported pixel-format has been set. This virtio-gpu "
+                "currently only supports B8G8R8X8_UNORM.\n"));
+    }
+
+    returnResponseOkEarly(pVirtqBuf, pCtrlHdr);
+
+    auto* resource {getResource(request.uResourceId)};
+    resource->format(request.uFormat);
+    resource->size(request.uWidth, request.uHeight);
+
+    returnResponseOkLate(pVirtqBuf, pCtrlHdr);
+}
+
+void VirtioGpuCmdHandler::cmdResourceUnref(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not checkCtrlqCmd("ResourceUnref", pVirtqBuf, pCtrlHdr, sizeof(virtioGpu::ResourceUnref),
+                          sizeof(virtioGpu::CtrlHdr))) {
+        return;
+    }
+
+    virtioGpu::ResourceUnref request;
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, request.payload(), sizeofPayload(request));
+    LogRel7(("virtio-gpu cmd handler: Got RESOURCE_UNREF command. (resource=%u)\n", request.uResourceId));
+
+    if (not checkResourceId("ResourceUnref", pVirtqBuf, pCtrlHdr, request.uResourceId)) {
+        return;
+    }
+
+    returnResponseOkEarly(pVirtqBuf, pCtrlHdr);
+
+    removeResource(request.uResourceId);
+
+    returnResponseOkLate(pVirtqBuf, pCtrlHdr);
+}
+
+void VirtioGpuCmdHandler::cmdSetScanout(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not checkCtrlqCmd("SetScanout", pVirtqBuf, pCtrlHdr, sizeof(virtioGpu::SetScanout),
+                          sizeof(virtioGpu::CtrlHdr))) {
+        return;
+    }
+
+    virtioGpu::SetScanout request;
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, request.payload(), sizeofPayload(request));
+    LogRel7(("virtio-gpu cmd handler: Got SET_SCANOUT command. (scanout=%u, resource=%u, rect=w:%u,h:%u,x:%u,y:%u)\n",
+             request.uScanoutId, request.uResourceId, request.r.width, request.r.height, request.r.x, request.r.y));
+
+    if (not checkScanoutId("SetScanout", pVirtqBuf, pCtrlHdr, request.uScanoutId)) {
+        return;
+    }
+
+    auto& currentScanout {getScanout(request.uScanoutId)->get()};
+    if (request.uResourceId == 0) {
+        LogRel2(("virtio-gpu cmd handler: SetScanout: Driver disabled scanout %u\n", request.uScanoutId));
+        currentScanout.fActive = false;
+        currentScanout.fNeedsResize = true;
+        currentScanout.detachDisplay();
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::OK_NODATA);
+        return;
+    }
+
+    if (not checkResourceId("SetScanout", pVirtqBuf, pCtrlHdr, request.uResourceId)) {
+        return;
+    }
+
+    returnResponseOkEarly(pVirtqBuf, pCtrlHdr);
+
+    currentScanout.fActive = true;
+    currentScanout.uResourceId = request.uResourceId;
+    if (not currentScanout.isAttachedToDisplay()) {
+        currentScanout.attachDisplay();
+        currentScanout.fNeedsResize = true;
+    }
+
+    resizeScanout(request.uScanoutId, request.r.width, request.r.height);
+
+    returnResponseOkLate(pVirtqBuf, pCtrlHdr);
+}
+
+void VirtioGpuCmdHandler::cmdResourceFlush(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not checkCtrlqCmd("ResourceFlush", pVirtqBuf, pCtrlHdr, sizeof(virtioGpu::ResourceFlush),
+                          sizeof(virtioGpu::CtrlHdr))) {
+        return;
+    }
+
+    virtioGpu::ResourceFlush request;
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, request.payload(), sizeofPayload(request));
+    LogRel7(("virtio-gpu cmd handler: Got RESOURCE_FLUSH command. (resource=%u, rect=w:%u,h:%u,x:%u,y:%u)\n",
+             request.uResourceId, request.r.width, request.r.height, request.r.x, request.r.y));
+
+    if (not checkResourceId("ResourceFlush", pVirtqBuf, pCtrlHdr, request.uResourceId)) {
+        return;
+    }
+
+    auto scanouts {getScanoutsByResource(request.uResourceId)};
+    if (scanouts.empty()) {
+        LogRel(
+            ("virtio-gpu cmd handler: ResourceFlush: No scanout is assigned to resource %u.\n", request.uResourceId));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_INVALID_RESOURCE_ID);
+        return;
+    }
+
+    returnResponseOkEarly(pVirtqBuf, pCtrlHdr);
+
+    for (auto& scanout : scanouts) {
+        if (scanout.get().hasDisplay()) {
+            scanout.get().flush();
+        }
+    }
+
+    returnResponseOkLate(pVirtqBuf, pCtrlHdr);
+}
+
+void VirtioGpuCmdHandler::cmdTransferToHost2d(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not checkCtrlqCmd("TransferToHost2D", pVirtqBuf, pCtrlHdr, sizeof(virtioGpu::TransferToHost2d),
+                          sizeof(virtioGpu::CtrlHdr))) {
+        return;
+    }
+
+    virtioGpu::TransferToHost2d request;
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, request.payload(), sizeofPayload(request));
+    LogRel7(("virtio-gpu cmd handler: Got TRANSFER_TO_HOST_2D command. (resource=%u, offset=%lu, "
+             "rect=w:%u,h:%u,x:%u,y:%u)\n",
+             request.uResourceId, request.uOffset, request.r.width, request.r.height, request.r.x, request.r.y));
+
+    if (not checkResourceId("TransferToHost2D", pVirtqBuf, pCtrlHdr, request.uResourceId)) {
+        return;
+    }
+
+    auto scanouts {getScanoutsByResource(request.uResourceId)};
+    if (scanouts.empty()) {
+        LogRel(
+            ("virtio-gpu cmd handler: ResourceFlush: No scanout is assigned to resource %u.\n", request.uResourceId));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_INVALID_RESOURCE_ID);
+        return;
+    }
+
+    returnResponseOkEarly(pVirtqBuf, pCtrlHdr);
+
+    auto* resource {getResource(request.uResourceId)};
+    auto vMapping {memoryAdapter_.mapGCPhys2HCVirt(resource->getBacking())};
+
+    PRTSGSEG paSegments {static_cast<PRTSGSEG>(RTMemAllocZ(sizeof(RTSGSEG) * vMapping.size()))};
+    for (auto idx {0u}; idx < vMapping.size(); idx++) {
+        const auto& mapping {vMapping.at(idx)};
+        paSegments[idx].pvSeg = mapping.uAddr_;
+        paSegments[idx].cbSeg = mapping.uLength_;
+    }
+
+    PRTSGBUF pSegBuf {static_cast<PRTSGBUF>(RTMemAllocZ(sizeof(RTSGBUF)))};
+
+    for (auto& wrappedScanout : scanouts) {
+        auto& scanout {wrappedScanout.get()};
+        if (not scanout.fActive) {
+            LogRel(("virtio-gpu cmd handler: TransferToHost2D: Prevented copying into disabled scanout %u.\n",
+                    scanout.uScanoutId));
+            continue;
+        }
+
+        /*
+         * If the size is 64x64, then this is the resource of the mouse cursor.
+         * As we currently ignore the cursorq, we just do nothing in this case.
+         */
+        if ((resource->width() > 64u and resource->height() > 64u) and scanout.hasDisplay()
+            and resource->getBacking().size() > 0
+            /*
+             * TODO: at the moment we always assume that offset=0 and r.x=0 and r.y=0,
+             * i.e. the driver always sends a full frame, not just parts of a frame.
+             * This is currently only used by Linux and not by the customers driver,
+             * thus we ignore cases where this assumption isn't true.
+             */
+            and request.r == virtioGpu::Rect {resource->width(), resource->height()}) {
+            RTSgBufInit(pSegBuf, paSegments, vMapping.size());
+            auto [pFrameBuffer, cbFrameBuffer] {scanout.rDisplayManager.acquireBackingStore(scanout.uScanoutId)};
+            if (pFrameBuffer != nullptr) {
+                RTSgBufCopyToBuf(pSegBuf, pFrameBuffer, cbFrameBuffer);
+            }
+            scanout.rDisplayManager.releaseBackingStore();
+        }
+    }
+
+    RTMemFree(pSegBuf);
+    RTMemFree(paSegments);
+
+    memoryAdapter_.releaseMappings(vMapping);
+
+    returnResponseOkLate(pVirtqBuf, pCtrlHdr);
+}
+
+void VirtioGpuCmdHandler::cmdResourceAttachBacking(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not checkCtrlqCmd("ResourceAttachBacking", pVirtqBuf, pCtrlHdr, sizeof(virtioGpu::ResourceAttachBacking),
+                          sizeof(virtioGpu::CtrlHdr))) {
+        return;
+    }
+
+    virtioGpu::ResourceAttachBacking request;
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, request.payload(), sizeofPayload(request));
+    LogRel7(("virtio-gpu cmd handler: Got RESOURCE_ATTACH_BACKING command. (resource=%u)\n", request.uResourceId));
+
+    if (pVirtqBuf->cbPhysSend < (request.uNrEntries * sizeof(virtioGpu::ResourceMemEntry))) {
+        LogRel(("virtio-gpu cmd handler: ResourceAttachBacking: request buffer too small for all memory entries.\n"));
+        returnResponseNoData(pVirtqBuf, pCtrlHdr, virtioGpu::CtrlType::Response::ERR_OUT_OF_MEMORY);
+        return;
+    }
+
+    if (not checkResourceId("ResourceAttachBacking", pVirtqBuf, pCtrlHdr, request.uResourceId)) {
+        return;
+    }
+
+    returnResponseOkEarly(pVirtqBuf, pCtrlHdr);
+
+    auto* resource {getResource(request.uResourceId)};
+    resource->reserveBacking(request.uNrEntries);
+
+    const size_t cbEntries {sizeof(virtioGpu::ResourceMemEntry) * request.uNrEntries};
+    virtioGpu::ResourceMemEntry* pEntries {static_cast<virtioGpu::ResourceMemEntry*>(RTMemAlloc(cbEntries))};
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, pEntries, cbEntries);
+
+    for (auto idx {0u}; idx < request.uNrEntries; idx++) {
+        resource->addBacking(pEntries[idx].uAddr, pEntries[idx].uLength);
+    }
+
+    RTMemFree(pEntries);
+
+    returnResponseOkLate(pVirtqBuf, pCtrlHdr);
+}
+
+void VirtioGpuCmdHandler::cmdResourceDetachBacking(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr)
+{
+    if (not checkCtrlqCmd("ResourceDetachBacking", pVirtqBuf, pCtrlHdr, sizeof(virtioGpu::ResourceDetachBacking),
+                          sizeof(virtioGpu::CtrlHdr))) {
+        return;
+    }
+
+    virtioGpu::ResourceDetachBacking request;
+    virtioAdapter_.virtqBufDrain(pVirtqBuf, request.payload(), sizeofPayload(request));
+    LogRel7(("virtio-gpu cmd handler: Got RESOURCE_DETACH_BACKING command. (resource=%u)\n", request.uResourceId));
+
+    if (not checkResourceId("ResourceDetachBacking", pVirtqBuf, pCtrlHdr, request.uResourceId)) {
+        return;
+    }
+
+    returnResponseOkEarly(pVirtqBuf, pCtrlHdr);
+
+    auto* resource {getResource(request.uResourceId)};
+    resource->clearBacking();
+
+    returnResponseOkLate(pVirtqBuf, pCtrlHdr);
+}
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpuCmdHandler.hpp b/src/VBox/Devices/Graphics/DevVirtioGpuCmdHandler.hpp
new file mode 100644
index 0000000000..7cf4bf583d
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpuCmdHandler.hpp
@@ -0,0 +1,353 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#pragma once
+
+#include <VBox/types.h>
+#include <VBox/vmm/pdmdev.h>
+#include <VBox/vmm/stam.h>
+
+#include <iprt/mem.h>
+#include <iprt/cpp/lock.h>
+
+#include "../VirtIO/VirtioCore.h"
+
+#include "DevVirtioGpuResource.hpp"
+#include "DevVirtioGpuDefinitions.hpp"
+
+#include <array>
+#include <functional>
+#include <memory>
+#include <optional>
+#include <tuple>
+#include <vector>
+
+class VirtioGpuCmdHandler
+{
+public:
+    /**
+     * A VirtioAdapter encapsulates functions to receive data from a virtq,
+     * put data into a virtq and signal to the guest that there is new data
+     * in a virtq.
+     */
+    class VirtioAdapter
+    {
+    public:
+        /* Drains cb bytes from the pVirtqBuf into pv. */
+        virtual void virtqBufDrain(PVIRTQBUF pVirtqBuf, void* pv, size_t cb) = 0;
+
+        /* Puts pv into the used ring and thus sends data to the guest. */
+        virtual void virtqBufPut(PVIRTQBUF pVirtqBuf, void* pv, size_t cb) = 0;
+
+        /* Informs the guest driver about new data in the virtq. */
+        virtual void virtqSyncRings(PVIRTQBUF pVirtqBuf) = 0;
+    };
+
+    /**
+     * The DisplayManager is the interface to the virtual displays provided by
+     * the hypervisor platform.
+     * It is responsible for updating the dimensions and the frames of the
+     * virtual displays according to the data in the scanouts.
+     */
+    class DisplayManager
+    {
+    public:
+        /**
+         * The Backing store information
+         */
+        using BackingStoreInfo = std::pair<void*, size_t>;
+        using Dimension = std::pair<uint32_t, uint32_t>;
+
+        /**
+         * Check whether the display index is managed by the Manager.
+         *
+         * \param displayIndex The display index.
+         *
+         * \return true if the display is managed, false otherwise
+         */
+        virtual bool isManaged(uint32_t displayIndex) = 0;
+
+        /**
+         * Obtain the dimensions of the given display.
+         *
+         * \param displayIndex The display index
+         *
+         * \return the dimension of the display or <0,0> if not managed
+         */
+        virtual Dimension displayDimension(uint32_t displayIndex) = 0;
+
+        /**
+         * Resize the given display to the given width and height.
+         *
+         * \param displayIndex The display index
+         * \param uWidth display width
+         * \param uHeigth display height
+         * \param i32OriginX The x position of the display to resize
+         * \param i32OriginY The y position of the display to resize
+         */
+        virtual void resize(uint32_t displayIndex, uint32_t uWidth, uint32_t uHeight,
+                            std::optional<int32_t> i32OriginX = std::nullopt,
+                            std::optional<int32_t> i32OriginY = std::nullopt) = 0;
+
+        /**
+         * Attaches the virtio-gpu to the given display.
+         *
+         * \param displayIndex The display index
+         */
+        virtual int attachDisplay(uint32_t displayIndex) = 0;
+
+        /**
+         * Detaches the virtio-gpu from the given display.
+         *
+         * \param displayIndex The display index
+         */
+        virtual void detachDisplay(uint32_t displayIndex) = 0;
+
+        /**
+         * Check attachment status of the given display.
+         *
+         * \param displayIndex The display index
+         *
+         * \return true if the display is attached, false otherwise.
+         */
+        virtual bool isAttached(uint32_t displayIndex) = 0;
+
+        /**
+         * Displays the framebuffer content on the display.
+         *
+         * \param displayIndex The display index
+         */
+        virtual void display(uint32_t displayIndex) = 0;
+
+        /**
+         * Obtain backing store information.
+         *
+         * \param displayIndex The display index
+         *
+         * \return Backing store information
+         */
+        virtual BackingStoreInfo acquireBackingStore(uint32_t displayIndex) = 0;
+
+        /**
+         * Releases the backing store, after an update of the frame buffer is done.
+         */
+        virtual void releaseBackingStore() = 0;
+    };
+
+    /**
+     * A memoryAdapter is used to map guest physical addresses into the host's
+     * address space and to also unmap these mappings.
+     */
+    class MemoryAdapter
+    {
+    protected:
+        struct VirtioGpuMapping
+        {
+            void* uAddr_;            // The host virtual address
+            const uint32_t uLength_; // The size of the mapping
+            void* pv_;               // A pointer to data the adapter may need to free this mapping later
+
+            VirtioGpuMapping() = delete;
+            VirtioGpuMapping(void* uAddr, const uint32_t uLength, void* pv) : uAddr_(uAddr), uLength_(uLength), pv_(pv)
+            {}
+        };
+
+        using VecMemEntries = std::vector<VirtioGpuResource::MemEntry>;
+        using VecMappings = std::vector<VirtioGpuMapping>;
+
+    public:
+        /**
+         * Translates the guest physical addresses given in vBacking into host
+         * virtual addresses.
+         */
+        virtual VecMappings mapGCPhys2HCVirt(const VecMemEntries& vBacking) = 0;
+
+        /**
+         * Returns the mappings to the adapter so the adapter can do whatever
+         * is necessary.
+         */
+        virtual void releaseMappings(const VecMappings& vMapping) = 0;
+    };
+
+private:
+    VirtioAdapter& virtioAdapter_;
+    DisplayManager& displayManager_;
+    MemoryAdapter& memoryAdapter_;
+    const uint32_t numScanouts_;
+    RTCLockMtx mutex_;
+
+    struct Scanout
+    {
+        uint32_t uScanoutId {0};
+        uint32_t uResourceId {0};
+        uint32_t uCurrentWidth {0};
+        uint32_t uCurrentHeight {0};
+        uint32_t uResizedWidth {0u};
+        uint32_t uResizedHeight {0u};
+        bool fActive {false};
+        bool fNeedsResize {true};
+        bool fResizeRequested {false};
+
+        DisplayManager& rDisplayManager;
+
+        Scanout() = delete;
+        Scanout(DisplayManager& dManager) : rDisplayManager(dManager) {}
+
+        bool hasDisplay() const { return rDisplayManager.isManaged(uScanoutId); }
+
+        bool isAttachedToDisplay() const { return hasDisplay() and rDisplayManager.isAttached(uScanoutId); }
+
+        void attachDisplay() const
+        {
+            if (hasDisplay() and not isAttachedToDisplay()) {
+                rDisplayManager.attachDisplay(uScanoutId);
+            }
+        }
+
+        void detachDisplay() const
+        {
+            if (isAttachedToDisplay()) {
+                rDisplayManager.detachDisplay(uScanoutId);
+            }
+        }
+
+        DisplayManager::Dimension displayDimensions() const { return rDisplayManager.displayDimension(uScanoutId); }
+
+        void resizeDisplay() { rDisplayManager.resize(uScanoutId, uCurrentWidth, uCurrentHeight); }
+
+        void flush() { rDisplayManager.display(uScanoutId); }
+    };
+
+    using ScanoutRef = std::reference_wrapper<Scanout>;
+    using ScanoutCRef = std::reference_wrapper<const Scanout>;
+
+    std::vector<std::unique_ptr<VirtioGpuResource>> vResources_;
+
+    /* Returns a pointer to the resource with the given ID, or a nullptr if there is no resource with the given ID. */
+    inline VirtioGpuResource* getResource(uint32_t uResourceId);
+
+    /* Creates a resource with the given ID. Returns false if the ID was already in use, true otherwise. */
+    inline bool createResource(uint32_t uResourceId);
+
+    /* Removes the resource with the given ID. */
+    inline void removeResource(uint32_t uResourceId);
+
+    std::vector<Scanout> activeScanouts;
+
+    /* Returns true if the given scanout is in the range of existing scanouts (0 to NUM_MAX_SCANOUTS-1), false otherwise
+     */
+    inline bool scanoutExists(uint32_t uScanout);
+
+    /* Returns a reference to a scanout if the given scanout exists, an empty optional otherwise. */
+    inline std::optional<ScanoutRef> getScanout(uint32_t uScanout);
+
+    /**
+     * Returns a vector filled with references to all scanouts with the given resourceId, or an empty optional if no
+     * scanout is assigned to the given resourceId.
+     */
+    inline std::vector<ScanoutRef> getScanoutsByResource(uint32_t uResourceId);
+
+    /* Returns a dummy size to initialize the scanouts in case we are a secondary graphics controller. */
+    inline std::tuple<uint32_t, uint32_t> getDummySize()
+    {
+        return std::make_tuple(virtioGpu::INITIAL_WIDTH, virtioGpu::INITIAL_HEIGHT);
+    }
+
+public:
+    VirtioGpuCmdHandler() = delete;
+    VirtioGpuCmdHandler(VirtioAdapter& vAdapter, DisplayManager& dManager, MemoryAdapter& mAdapter,
+                        uint32_t numScanouts, bool attachDisplayLater);
+
+    ~VirtioGpuCmdHandler() = default;
+
+    /* Destroys all existing resources. */
+    void clearResources() { vResources_.clear(); }
+
+    /**
+     * Returns a const reference to the scanout with the given ID if it exists.
+     * That way another class working with the cmdHandler can't modify the scanouts.
+     */
+    std::optional<ScanoutCRef> getCScanout(uint32_t uScanout);
+
+    /**
+     * Requests resizing of the monitor. Sets the uResizedWidth and uResizedHeight variables of the associated scanout
+     * and sets scanout.fResizeRequested to true. The next getDisplayInfo or getEdid will then use the new resolution.
+     */
+    void requestResize(uint32_t uScanout, bool enabled, uint32_t uWidth, uint32_t uHeight);
+
+    /** Updates the current width and height of the given scanout and resizes display if necessary. */
+    inline void resizeScanout(uint32_t uScanout, uint32_t uWidth, uint32_t uHeight);
+
+    /* Handles the given virtq buffer and returns a response to the driver. */
+    void handleBuffer(PVIRTQBUF pVirtqBuf);
+
+    /* Does some basic sanity checking and returns an appropriate error to the guest if something is broken. */
+    inline bool checkCtrlqCmd(const char* cmdName, PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr, size_t cbSend,
+                              size_t cbReturn);
+
+    /* Checks wether the given scanout id is valid and returns a ERR_INVALID_SCANOUT_ID header to the guest if it isn't.
+     */
+    inline bool checkScanoutId(const char* cmdName, PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr,
+                               uint32_t uScanoutId);
+
+    /* Checks wether the given resource id is valid and returns a ERR_INVALID_RESOURCE_ID header to the guest if it
+     * isn't. */
+    inline bool checkResourceId(const char* cmdName, PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr,
+                                uint32_t uResourceId);
+
+    /* Returns a CtrlType::Response::OK_NODATA if the FENCE-flag is not set */
+    inline void returnResponseOkEarly(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Returns a CtrlType::Response::OK_NODATA if the FENCE-flag is set */
+    inline void returnResponseOkLate(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Returns a header with the given resonseType to the driver. */
+    inline void returnResponseNoData(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr,
+                                     virtioGpu::CtrlType::Response responseType);
+
+    /* Returns a response buffer to the driver. */
+    inline void returnResponseBuf(PVIRTQBUF pVirtqBuf, void* pv, size_t cb);
+
+    /* Returns the current output configureation to the driver. */
+    void cmdGetDisplayInfo(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Return the EDID data for a given scanout to the driver. */
+    void cmdGetEdid(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Creates a 2D resource on the host. */
+    void cmdResourceCreate2d(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Destroys a 2D resource. */
+    void cmdResourceUnref(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Sets the scanout parameters for a given output. */
+    void cmdSetScanout(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Flushes a resource to the screen. */
+    void cmdResourceFlush(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Transfers guest memory to host memory. */
+    void cmdTransferToHost2d(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Attaches backing pages to a resource. */
+    void cmdResourceAttachBacking(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+
+    /* Removes backing pages from a resource. */
+    void cmdResourceDetachBacking(PVIRTQBUF pVirtqBuf, virtioGpu::CtrlHdr* pCtrlHdr);
+};
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpuDefinitions.hpp b/src/VBox/Devices/Graphics/DevVirtioGpuDefinitions.hpp
new file mode 100644
index 0000000000..fbb2fa78e8
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpuDefinitions.hpp
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#pragma once
+
+#include <cstdint>
+
+namespace virtioGpu
+{
+
+constexpr uint32_t INITIAL_WIDTH {1920u};
+constexpr uint32_t INITIAL_HEIGHT {1080u};
+
+/**
+ * Virtio 1.2 - 4.1.2 PCI Device Discovery
+ * The PCI Device ID is calculated by adding 0x1040 to the Virtio Device ID.
+ */
+enum : uint16_t
+{
+    DEVICE_ID = 16,
+    PCI_DEVICE_ID = 0x1040 + DEVICE_ID,
+    PCI_CLASS_BASE = 0x03, ///< GPU
+    PCI_CLASS_SUB = 0x00,  ///< VGA compatible
+    PCI_CLASS_PROG = 0x00, ///< Unspecified
+    PCI_INTERRUPT_LINE = 0x00,
+    PCI_INTERRUPT_PIN = 0x01,
+};
+
+/**
+ * Virtio 1.2 - 5.7.1 GPU Device Feature bits
+ */
+enum Features : uint16_t
+{
+    VIRGIL = 1u << 0,        ///< virgl 3D mode is supported
+    EDID = 1u << 1,          ///< EDID (Extended Display Identification Data) is supported
+    RESOURCE_UUID = 1u << 2, ///< assigning resources UUIDs for export to other virtio devices is supported
+    RESOURCE_BLOB = 1u << 3, ///< creating and using size-based blob resources is supported
+    CONTEXT_INIT = 1u << 4,  ///< multiple context types and synchronization timelines supported
+};
+
+/**
+ * Virtio 1.2 - 5.7.2 GPU Device Virtqueues
+ */
+constexpr unsigned NUM_VIRTQUEUES {2u};
+
+enum VirtqIdx : uint16_t
+{
+    CONTROLQ = 0, ///< The index of the controlqueue
+    CURSORQ = 1,  ///< The index of the cursorqueue
+};
+
+/**
+ * Virtio 1.2 - 5.7.4 GPU Device configuration layout
+ * Virtio GPU device-specific configuration
+ */
+struct Config
+{
+    uint32_t uEventsRead {0u};  ///< Signals pending events to the driver
+    uint32_t uEventsClear {0u}; ///< Clears pending events in the device (write-to-clear)
+    uint32_t uNumScanouts {0u}; ///< Maximum number of scanouts supported (between 1 and 16 inclusive)
+    uint32_t uNumCapsets {0u};  ///< Maximum number of capability sets supported
+};
+
+static constexpr uint32_t EVENT_DISPLAY {
+    1u << 0}; ///< display configuration has changed and should be fetched by the driver
+
+/**
+ * Virtio 1.2 - 5.7.6.7 GPU Device Device Operation: Request header
+ */
+struct CtrlType
+{
+    enum Cmd : uint32_t
+    {
+        /* 2d commands */
+        GET_DISPLAY_INFO = 0x0100,
+        RESOURCE_CREATE_2D,
+        RESOURCE_UNREF,
+        SET_SCANOUT,
+        RESOURCE_FLUSH,
+        TRANSFER_TO_HOST_2D,
+        RESOURCE_ATTACH_BACKING,
+        RESOURCE_DETACH_BACKING,
+        GET_CAPSET_INFO,
+        GET_CAPSET,
+        GET_EDID,
+        RESOURCE_ASSIGN_UUID,
+        RESOURCE_ASSIGN_BLOB,
+        SET_SCANOUT_BLOB,
+
+        /* 3d commands */
+        CTX_CREATE = 0x0200,
+        CTX_DESTROY,
+        CTX_ATTACH_RESOURCE,
+        CTX_DETACH_RESOURCE,
+        RESOURCE_CREATE_3D,
+        TRANSFER_TO_HOST_3D,
+        TRANSFER_FROM_HOST_3D,
+        SUBMIT_3D,
+        RESOURCE_MAP_BLOB,
+        RESOURCE_UNMAP_BLOB,
+
+        /* cursor commands */
+        UPDATE_CURSOR = 0x0300,
+        MOVE_CURSOR,
+    };
+
+    enum Response : uint32_t
+    {
+        /* success responses */
+        OK_NODATA = 0x1100,
+        OK_DISPLAY_INFO,
+        OK_CAPSET_INFO,
+        OK_CAPSET,
+        OK_EDID,
+        OK_RESOURCE_UUID,
+        OK_MAP_INFO,
+
+        /* error responses */
+        ERR_UNSPEC = 0x1200,
+        ERR_OUT_OF_MEMORY,
+        ERR_INVALID_SCANOUT_ID,
+        ERR_INVALID_RESOURCE_ID,
+        ERR_INVALID_CONTEXT_ID,
+        ERR_INVALID_PARAMETER,
+    };
+};
+
+/**
+ * Virtio 1.2 - 5.7.6.8 GPU Device Operation: controlq
+ * VIRTIO_GPU_CMD_RESOURCE_CREATE_2D possible formats
+ */
+struct __attribute__((packed)) CtrlHdr
+{
+    uint32_t uType {0};    ///< type specifies the type of driver request or device response
+    uint32_t uFlags {0};   ///< flags request/response flags
+    uint64_t uFenceId {0}; ///< fence_id only important if FLAG_FENCE bit is set in flags
+    uint32_t uCtxId {0};   ///< ctx_id rendering context (3D mode only)
+    uint8_t uRingIdx {0};  ///< ring_idx
+    uint8_t uPadding[3];
+
+    CtrlHdr() = default;
+    CtrlHdr(uint32_t uCmd) : uType(uCmd) {}
+    CtrlHdr(CtrlType::Cmd uCmd) : uType(uCmd) {}
+
+    enum class Flags : uint32_t
+    {
+        FENCE = 1u << 0,
+        INFO_RING_IDX = 1u << 1,
+    };
+
+    /* Checks whether the given bit is set in uFlags */
+    inline bool has_flag(Flags flag) const { return (uFlags & static_cast<uint32_t>(flag)) != 0; };
+
+    /* Sets the given bit if fSet is true, otherwise clears it. */
+    inline void set_flag(Flags flag, bool fSet)
+    {
+        const uint32_t mask {static_cast<uint32_t>(flag)};
+        uFlags &= ~mask | fSet ? mask : 0u;
+    };
+
+    /* Transfers the fence-flag and uFenceId from other to this. */
+    inline void transfer_fence(const CtrlHdr* other)
+    {
+        if (other->has_flag(Flags::FENCE)) {
+            set_flag(Flags::FENCE, true);
+            uFenceId = other->uFenceId;
+        }
+    }
+};
+
+/*
+ * controlq command structure definitions
+ * See Virtio 1.2 - 5.7.6.8
+ */
+static void* removeHeader(void* pThis)
+{
+    return reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(pThis) + sizeof(CtrlHdr));
+}
+
+struct __attribute__((packed)) Rect
+{
+    uint32_t x {0};
+    uint32_t y {0};
+    uint32_t width {0};
+    uint32_t height {0};
+
+    Rect() = default;
+    Rect(uint32_t w, uint32_t h) : width(w), height(h) {}
+
+    friend bool operator==(const Rect& lhs, const Rect& rhs)
+    {
+        return lhs.x == rhs.x and lhs.y == rhs.y and lhs.width == rhs.width and lhs.height == rhs.height;
+    }
+
+    friend bool operator!=(const Rect& lhs, const Rect& rhs) { return not(lhs == rhs); }
+};
+
+struct __attribute__((packed)) DisplayOne
+{
+    Rect r;
+    uint32_t enabled {0};
+    uint32_t flags {0};
+};
+
+struct __attribute__((packed)) ResponseDisplayInfo
+{
+private:
+    static constexpr uint32_t NUM_MAX_SCANOUTS {16u};
+
+public:
+    CtrlHdr hdr {CtrlType::Response::OK_DISPLAY_INFO};
+    DisplayOne pmodes[NUM_MAX_SCANOUTS];
+
+    static size_t size(uint32_t num_scanouts) { return sizeof(CtrlHdr) + num_scanouts * sizeof(DisplayOne); }
+};
+
+struct __attribute__((packed)) GetEdid
+{
+    CtrlHdr hdr {CtrlType::Cmd::GET_EDID};
+    uint32_t uScanout {0};
+    uint32_t uPadding;
+
+    void* payload() { return removeHeader(this); }
+};
+
+struct __attribute__((packed)) ResponseEdid
+{
+    CtrlHdr hdr {CtrlType::Response::OK_EDID};
+    uint32_t uSize {0};
+    uint32_t uPadding;
+    uint8_t aEdid[1024] {0};
+};
+
+enum Format : uint32_t
+{
+    B8G8R8A8_UNORM = 1,
+    B8G8R8X8_UNORM = 2,
+    A8R8G8B8_UNORM = 3,
+    X8R8G8B8_UNORM = 4,
+
+    R8G8B8A8_UNORM = 67,
+    X8B8G8R8_UNORM = 68,
+
+    A8B8G8R8_UNORM = 121,
+    R8G8B8X8_UNORM = 134,
+};
+
+struct __attribute__((packed)) ResourceCreate2d
+{
+    CtrlHdr hdr {CtrlType::Cmd::RESOURCE_CREATE_2D};
+    uint32_t uResourceId {0};
+    uint32_t uFormat {0};
+    uint32_t uWidth {0};
+    uint32_t uHeight {0};
+
+    ResourceCreate2d() = default;
+    ResourceCreate2d(uint32_t id) : uResourceId(id) {}
+    ResourceCreate2d(uint32_t id, uint32_t w, uint32_t h) : uResourceId(id), uWidth(w), uHeight(h) {}
+
+    void* payload() { return removeHeader(this); }
+};
+
+struct __attribute__((packed)) ResourceUnref
+{
+    CtrlHdr hdr {CtrlType::Cmd::RESOURCE_UNREF};
+    uint32_t uResourceId {0};
+    uint32_t uPadding;
+
+    ResourceUnref() = default;
+    ResourceUnref(uint32_t id) : uResourceId(id) {}
+
+    void* payload() { return removeHeader(this); }
+};
+
+struct __attribute__((packed)) SetScanout
+{
+    CtrlHdr hdr {CtrlType::Cmd::SET_SCANOUT};
+    Rect r;
+    uint32_t uScanoutId {0};
+    uint32_t uResourceId {0};
+
+    SetScanout() = default;
+    SetScanout(uint32_t scanoutId, uint32_t resId) : uScanoutId(scanoutId), uResourceId(resId) {}
+    SetScanout(uint32_t scanoutId, uint32_t resId, uint32_t w, uint32_t h)
+        : r(w, h), uScanoutId(scanoutId), uResourceId(resId)
+    {}
+
+    void* payload() { return removeHeader(this); }
+};
+
+struct __attribute__((packed)) ResourceFlush
+{
+    CtrlHdr hdr {CtrlType::Cmd::RESOURCE_FLUSH};
+    Rect r;
+    uint32_t uResourceId {0};
+    uint32_t uPadding;
+
+    void* payload() { return removeHeader(this); }
+};
+
+struct __attribute__((packed)) TransferToHost2d
+{
+    CtrlHdr hdr {CtrlType::Cmd::TRANSFER_TO_HOST_2D};
+    Rect r;
+    uint64_t uOffset {0};
+    uint32_t uResourceId {0};
+    uint32_t uPadding;
+
+    TransferToHost2d() = default;
+    TransferToHost2d(uint32_t resId) : uResourceId(resId) {}
+    TransferToHost2d(uint32_t resId, uint32_t w, uint32_t h) : r(w, h), uResourceId(resId) {}
+
+    void* payload() { return removeHeader(this); }
+};
+
+struct __attribute__((packed)) ResourceAttachBacking
+{
+    CtrlHdr hdr {CtrlType::Cmd::RESOURCE_ATTACH_BACKING};
+    uint32_t uResourceId {0};
+    uint32_t uNrEntries {0};
+
+    void* payload() { return removeHeader(this); }
+};
+
+struct __attribute__((packed)) ResourceMemEntry
+{
+    uint64_t uAddr {0};
+    uint32_t uLength {0};
+    uint32_t uPadding;
+};
+
+struct __attribute__((packed)) ResourceDetachBacking
+{
+    CtrlHdr hdr {CtrlType::Cmd::RESOURCE_DETACH_BACKING};
+    uint32_t uResourceId {0};
+    uint32_t uPadding;
+
+    ResourceDetachBacking() = default;
+    ResourceDetachBacking(uint32_t id) : uResourceId(id) {}
+
+    void* payload() { return removeHeader(this); }
+};
+
+} // namespace virtioGpu
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpuDisplayManager.cpp b/src/VBox/Devices/Graphics/DevVirtioGpuDisplayManager.cpp
new file mode 100644
index 0000000000..7a04ca9d5c
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpuDisplayManager.cpp
@@ -0,0 +1,413 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#define LOG_GROUP LOG_GROUP_DEV_VIRTIO_GPU
+#include "DevVirtioGpuDisplayManager.hpp"
+
+#include "DevVirtioGpuResource.hpp"
+#include <VBox/log.h>
+#include <VBox/types.h>
+#include <VBox/vmm/pdmapi.h>
+#include <VBox/vmm/vm.h>
+
+#include <cyberus/edid.hpp>
+
+#include <algorithm>
+
+VirtioGpuDisplayManager::VirtioGpuDisplayManager(PPDMDEVINS pDevIns_, unsigned iLUN_, PDMIBASE& iBase_,
+                                                 uint32_t u32VRamSize, uint32_t u32MonitorCount_)
+    : pDevIns(pDevIns_), iLUN(iLUN_), iBase(iBase_), u32MonitorCount(u32MonitorCount_)
+{
+    vram.resize(u32VRamSize);
+
+    uint32_t viewIndex {0ul};
+
+    auto generateDisplays = [&viewIndex, &u32VRamSize]() {
+        Display display;
+        display.view.u32ViewIndex = viewIndex;
+        display.view.u32ViewSize = u32VRamSize;
+        /*
+         * We allow the free use of the assigned VRAM, so it is irrelevant if
+         * there are multiple monitors of a mid size resolution or one single monitor with a huge resolution
+         */
+        display.view.u32MaxScreenSize = u32VRamSize;
+
+        display.screen.u32ViewIndex = viewIndex;
+        display.screen.u16BitsPerPixel = VirtioGpuResource::BYTES_PER_PIXEL * __CHAR_BIT__;
+        display.screen.u32Width = virtioGpu::INITIAL_WIDTH;
+        display.screen.u32Height = virtioGpu::INITIAL_HEIGHT;
+
+        display.screen.i32OriginX = viewIndex * virtioGpu::INITIAL_WIDTH;
+        display.screen.i32OriginY = 0;
+
+        display.screen.u16Flags = VBVA_SCREEN_F_DISABLED;
+
+        viewIndex++;
+
+        return display;
+    };
+
+    std::generate_n(std::back_insert_iterator<std::vector<Display>>(displays), u32MonitorCount, generateDisplays);
+    std::memset(vram.data(), 0, vram.size());
+}
+
+VirtioGpuDisplayManager::~VirtioGpuDisplayManager()
+{}
+
+void VirtioGpuDisplayManager::reset()
+{
+    DriverGuard _ {driverMtx};
+
+    if (not pDrv) {
+        return;
+    }
+
+    if (pDrv->pfnReset != nullptr) {
+        pDrv->pfnReset(pDrv);
+    }
+}
+
+bool VirtioGpuDisplayManager::isManaged(uint32_t displayIndex)
+{
+    return displayIndex < u32MonitorCount;
+}
+
+VirtioGpuDisplayManager::Dimension VirtioGpuDisplayManager::displayDimension(uint32_t displayIndex)
+{
+    if (not isManaged(displayIndex)) {
+        return {0, 0};
+    }
+
+    DriverGuard _ {driverMtx};
+
+    auto& display {displays.at(displayIndex)};
+
+    return {display.screen.u32Width, display.screen.u32Height};
+}
+
+void VirtioGpuDisplayManager::resize(uint32_t displayIndex, uint32_t uWidth, uint32_t uHeight,
+                                     std::optional<int32_t> i32OriginX, std::optional<int32_t> i32OriginY)
+{
+    if (not isAttached(displayIndex)) {
+        return;
+    }
+
+    DriverGuard _ {driverMtx};
+
+    auto& screen {displays.at(displayIndex).screen};
+
+    const uint32_t bytesPerPixel {screen.u16BitsPerPixel / static_cast<unsigned>(__CHAR_BIT__)};
+
+    int32_t newOriginX {i32OriginX.value_or(screen.i32OriginX)};
+    int32_t newOriginY {i32OriginY.value_or(screen.i32OriginY)};
+
+    screen.u32LineSize = uWidth * bytesPerPixel;
+    screen.u32Width = uWidth;
+    screen.u32Height = uHeight;
+    screen.i32OriginX = newOriginX;
+    screen.i32OriginY = newOriginY;
+
+    /*
+     * The Framebuffers of all displays are handled in a consecutive buffer of memory by VBox, which is called the VRAM
+     * During a Monitor resize, the portion of memory used for the desired monitor changes.
+     * Thus we need to adjust the start offset of the next monitor to avoid wrong graphics output.
+     */
+    for (uint32_t i {displayIndex + 1}; i < displays.size(); ++i) {
+        auto& currentScreen {displays.at(i).screen};
+        auto& previousScreen {displays.at(i - 1).screen};
+
+        auto calculateScreenSize = [](auto& screen_) -> uint32_t {
+            return screen_.u32Width * screen_.u32Height
+                   * (screen_.u16BitsPerPixel / static_cast<unsigned>(__CHAR_BIT__));
+        };
+
+        uint32_t previousScreenSize {calculateScreenSize(previousScreen)};
+        uint32_t newStartOffset {previousScreen.u32StartOffset + previousScreenSize};
+
+        currentScreen.u32StartOffset = newStartOffset;
+
+        int64_t xOffset {previousScreen.i32OriginX + previousScreen.u32Width};
+
+        currentScreen.i32OriginX = xOffset;
+        resizeVBVA(i, true);
+
+        uint32_t screenSize {calculateScreenSize(currentScreen)};
+        AssertLogRelMsg((currentScreen.u32StartOffset + screenSize) < vram.size(),
+                        ("VirtioGpuDisplayManager: The framebuffer for the displays starting with index %u does not "
+                         "fit into VRAM, monitorCount %u \n",
+                         i, displays.size()));
+    }
+
+    resizeVBVA(displayIndex, true);
+}
+
+int VirtioGpuDisplayManager::attachDisplay(uint32_t displayIndex)
+{
+    int rc {VINF_SUCCESS};
+    if (isAttached(displayIndex)) {
+        return VINF_SUCCESS;
+    }
+
+    if (not isManaged(displayIndex)) {
+        return VERR_NOT_AVAILABLE;
+    }
+
+    {
+        DriverGuard _ {driverMtx};
+
+        auto& display {displays.at(displayIndex)};
+
+        LogRel6(("VirtioGpuDisplayManager: attaching monitor %u .\n", display.view.u32ViewIndex));
+
+        display.screen.u16Flags = VBVA_SCREEN_F_ACTIVE;
+    }
+
+    if (not allDisplaysDetached() and not ownDisplay) {
+        PVM pVM {PDMDevHlpGetVM(pDevIns)};
+
+        rc = PDMR3DriverDetach(pVM->pUVM, "vga", 0, 0, NULL, 0, PDM_TACH_FLAGS_NOT_HOT_PLUG);
+        AssertLogRel(RT_SUCCESS(rc));
+
+        rc = PDMR3DriverAttach(pVM->pUVM, "vga", 0, 0, PDM_ATTACH_DUMMY_DRIVER, NULL);
+
+        if (not pDrv) {
+            rc = takeoverDriver();
+            AssertLogRel(RT_SUCCESS(rc));
+        }
+        ownDisplay = true;
+        return rc;
+    }
+
+    rc = enableVBVA(displayIndex);
+    AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+    rc = resizeVBVA(displayIndex, false);
+    AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+    return rc;
+}
+
+void VirtioGpuDisplayManager::detachDisplay(uint32_t displayIndex)
+{
+    if (not isAttached(displayIndex)) {
+        LogRel(("Display %d not attached. Not going to do anything\n", displayIndex));
+        return;
+    }
+
+    DriverGuard _ {driverMtx};
+
+    if (not isManaged(displayIndex)) {
+        LogRel(("Display %d not managed. Not going to do anything\n", displayIndex));
+        return;
+    }
+
+    auto& display {displays.at(displayIndex)};
+
+    LogRel6(("VirtioGpuDisplayManager: detaching monitor %u.\n", displayIndex));
+
+    display.screen.u16Flags = VBVA_SCREEN_F_DISABLED;
+
+    /**
+     * On display termination, the pDrv is handed back to VBox already. Thus
+     * the error code VERR_NOT_AVAILABLE is reported here.
+     */
+    resizeVBVA(displayIndex, false);
+
+    disableVBVA(displayIndex);
+}
+
+bool VirtioGpuDisplayManager::isAttached(uint32_t displayIndex)
+{
+    DriverGuard _ {driverMtx};
+
+    if (not isManaged(displayIndex)) {
+        return false;
+    }
+
+    auto& display {displays.at(displayIndex)};
+
+    return display.screen.u16Flags & VBVA_SCREEN_F_ACTIVE;
+}
+
+void VirtioGpuDisplayManager::display(uint32_t displayIndex)
+{
+    if (not isAttached(displayIndex)) {
+        return;
+    }
+
+    DriverGuard _ {driverMtx};
+    if (pDrv != nullptr) {
+        auto& screen {displays.at(displayIndex).screen};
+        VBVACMDHDR cmd;
+
+        cmd.x = screen.i32OriginX;
+        cmd.y = screen.i32OriginY;
+        cmd.w = screen.u32Width;
+        cmd.h = screen.u32Height;
+
+        pDrv->pfnVBVAUpdateBegin(pDrv, screen.u32ViewIndex);
+        pDrv->pfnVBVAUpdateProcess(pDrv, screen.u32ViewIndex, &cmd, sizeof(cmd));
+        pDrv->pfnVBVAUpdateEnd(pDrv, screen.u32ViewIndex, screen.i32OriginX, screen.i32OriginY, screen.u32Width,
+                               screen.u32Height);
+    }
+}
+
+VirtioGpuDisplayManager::BackingStoreInfo VirtioGpuDisplayManager::acquireBackingStore(uint32_t displayIndex)
+{
+    driverMtx.lock();
+
+    if (not isManaged(displayIndex) or pDrv == nullptr) {
+        return {nullptr, 0};
+    }
+
+    auto& screen {displays.at(displayIndex).screen};
+
+    uint8_t* pFramebuffer {vram.data() + screen.u32StartOffset};
+    size_t cbFramebuffer {screen.u32Width * screen.u32Height
+                          * (screen.u16BitsPerPixel / static_cast<unsigned>(__CHAR_BIT__))};
+
+    return {pFramebuffer, cbFramebuffer};
+}
+
+void VirtioGpuDisplayManager::releaseBackingStore()
+{
+    driverMtx.unlock();
+}
+
+bool VirtioGpuDisplayManager::allDisplaysDetached()
+{
+    auto attachementFn = [](Display& display) { return display.screen.u16Flags & VBVA_SCREEN_F_ACTIVE; };
+
+    return std::find_if(displays.begin(), displays.end(), attachementFn) == displays.end();
+}
+
+int VirtioGpuDisplayManager::takeoverDriver()
+{
+    int rc {VINF_SUCCESS};
+
+    if (pDrvBase == nullptr) {
+        rc = PDMDevHlpDriverAttach(pDevIns, iLUN, &iBase, &pDrvBase, "Display Port");
+    }
+
+    if (rc == VERR_PDM_NO_ATTACHED_DRIVER) {
+        AssertLogRelMsgFailed(("VirtioGpuDisplayManager: %s/%d: warning: no driver attached to LUN #0!\n",
+                               pDevIns->pReg->szName, pDevIns->iInstance));
+        return VINF_SUCCESS;
+    } else if (not RT_SUCCESS(rc)) {
+        AssertLogRelMsgFailed(("VirtioGpuDisplayManager: failed to attach LUN #0! rc=%Rrc\n", rc));
+        return rc;
+    }
+
+    /* rc == VINF_SUCCESS, i.e. pDrvBase is attached to iLUN */
+
+    pDrv = PDMIBASE_QUERY_INTERFACE(pDrvBase, PDMIDISPLAYCONNECTOR);
+    if (pDrv != nullptr) {
+        if (pDrv->pfnRefresh == nullptr or pDrv->pfnResize == nullptr or pDrv->pfnUpdateRect == nullptr) {
+            Assert(pDrv->pfnRefresh != nullptr);
+            Assert(pDrv->pfnResize != nullptr);
+            Assert(pDrv->pfnUpdateRect != nullptr);
+            pDrv = nullptr;
+            pDrvBase = nullptr;
+            rc = VERR_INTERNAL_ERROR;
+        }
+    } else {
+        AssertLogRelMsgFailed(
+            ("VirtioGpuDisplayManager: LUN #0 doesn't have a display connector interface! rc=%Rrc\n", rc));
+        pDrvBase = nullptr;
+        rc = VERR_PDM_MISSING_INTERFACE;
+    }
+
+    LogRel2(("VirtioGpuDisplayDriver: Display Port Driver attached\n"));
+
+    /*
+     * We deactivate the rendering of the mouse cursor by VBox, as the intel driver of the Windows
+     * VM renders the mouse cursor for the VM already.
+     */
+    pDrv->pfnVBVAMousePointerShape(pDrv, false, false, 0, 0, 0, 0, nullptr);
+    return rc;
+}
+
+void VirtioGpuDisplayManager::handoverDriver()
+{
+    PVM pVM {PDMDevHlpGetVM(pDevIns)};
+    PDMR3DriverDetach(pVM->pUVM, "virtio-gpu", 0, 0, NULL, 0, 0);
+    PDMR3DriverAttach(pVM->pUVM, "vga", 0, 0, PDM_TACH_FLAGS_NOT_HOT_PLUG, NULL);
+
+    pDrv = nullptr;
+    pDrvBase = nullptr;
+    ownDisplay = false;
+
+    LogRel2(("VirtioGpuDisplayDriver: Display Port Driver detached\n"));
+}
+
+void VirtioGpuDisplayManager::detachAllDisplays()
+{
+    for (auto i {0ul}; i < displays.size(); ++i) {
+        detachDisplay(i);
+    }
+}
+
+int VirtioGpuDisplayManager::resizeVBVA(uint32_t displayIndex, bool fResetInputMapping)
+{
+    AssertLogRelMsgReturn(isManaged(displayIndex),
+                          ("VirtioGpuDisplayManager: UpdateVBVA: The Display %u is not managed! \n", displayIndex),
+                          VERR_INVALID_PARAMETER);
+
+    int rc {VERR_NOT_AVAILABLE};
+
+    if (pDrv != nullptr and pDrv->pfnVBVAResize != nullptr) {
+        AssertRelease(isManaged(displayIndex));
+
+        auto& display {displays.at(displayIndex)};
+
+        return pDrv->pfnVBVAResize(pDrv, &display.view, &display.screen, vram.data(), fResetInputMapping);
+    }
+
+    LogRel6(("VirtioGpuDisplayManager: tried to update VBVA for display %u. Return Code: %Rrc.\n", displayIndex, rc));
+
+    return rc;
+}
+
+int VirtioGpuDisplayManager::enableVBVA(uint32_t displayIndex)
+{
+    AssertLogRelMsgReturn(isManaged(displayIndex),
+                          ("VirtioGpuDisplayManager: EnableVBVA: The display %u is not managed! \n", displayIndex),
+                          VERR_INVALID_PARAMETER);
+
+    int rc {VERR_NOT_AVAILABLE};
+
+    if (pDrv != nullptr and pDrv->pfnVBVAEnable != nullptr) {
+        rc = pDrv->pfnVBVAEnable(pDrv, displayIndex, 0);
+    }
+
+    LogRel6(("VirtioGpuDisplayManager: tried to enable VBVA for display %u. Return Code: %Rrc.\n", displayIndex, rc));
+
+    return rc;
+}
+
+void VirtioGpuDisplayManager::disableVBVA(uint32_t displayIndex)
+{
+    AssertReleaseMsg(isManaged(displayIndex),
+                     ("VirtioGpuDisplayManager: disableVBVA: The display %u is not managed! \n", displayIndex));
+
+    if (pDrv != nullptr and pDrv->pfnVBVADisable != nullptr) {
+        pDrv->pfnVBVADisable(pDrv, displayIndex);
+        LogRel6(("VirtioGpuDisplayManager: disabled VBVA for display %u.\n", displayIndex));
+    }
+}
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpuDisplayManager.hpp b/src/VBox/Devices/Graphics/DevVirtioGpuDisplayManager.hpp
new file mode 100644
index 0000000000..838a23602d
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpuDisplayManager.hpp
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#pragma once
+
+#include <VBox/vmm/pdmdev.h>
+#include <VBox/vmm/pdmifs.h>
+#include <VBox/vmm/pgm.h>
+
+#include "DevVirtioGpuCmdHandler.hpp"
+#include <VBox/Graphics/VBoxVideo.h>
+
+#include <mutex>
+
+/**
+ * The Virtio Display Manager implementation.
+ *
+ */
+class VirtioGpuDisplayManager final : public VirtioGpuCmdHandler::DisplayManager
+{
+public:
+    VirtioGpuDisplayManager() = delete;
+
+    /**
+     * The Virtio GPU Display Manager.
+     *
+     * \param pDevINs_ The VBox PDM Device Instance Data
+     * \param iLUN_ The device LUN of the GPU
+     * \param iBase_ The Virtio GPU Interface Base
+     * \param u32VRamSize The assigned VRAM
+     * \param u32MonitorCount The maximum active monitor count
+     */
+    VirtioGpuDisplayManager(PPDMDEVINS pDevIns_, unsigned iLUN_, PDMIBASE& iBase_, uint32_t u32VRamSize,
+                            uint32_t u32MonitorCount);
+
+    ~VirtioGpuDisplayManager();
+
+    /**
+     * Reset the Display infrastructure
+     */
+    void reset();
+
+    /**
+     * Check whether the display index is managed by the Manager.
+     *
+     * \param displayIndex The display index.
+     *
+     * \return true if the display is managed, false otherwise
+     */
+    virtual bool isManaged(uint32_t displayIndex) final;
+
+    /**
+     * Obtain the dimensions of the given display.
+     *
+     * \param displayIndex The display index
+     *
+     * \return the dimension of the display or <0,0> if not managed
+     */
+    virtual Dimension displayDimension(uint32_t displayIndex) final;
+
+    /**
+     * Resize the given display to the given width and height.
+     *
+     * \param displayIndex The display index
+     * \param uWidth display width
+     * \param uHeigth display height
+     * \param u32OriginX (Optional) The display x position
+     * \param u32OriginY (Optional) The display y position
+     */
+    virtual void resize(uint32_t displayIndex, uint32_t uWidth, uint32_t uHeight, std::optional<int32_t> i32OriginX,
+                        std::optional<int32_t> i32OriginY) final;
+
+    /**
+     * Attaches the virtio-gpu to the given display.
+     *
+     * \param displayIndex The display index
+     */
+    virtual int attachDisplay(uint32_t displayIndex) final;
+
+    /**
+     * Detaches the virtio-gpu from the given display.
+     *
+     * \param displayIndex The display index
+     */
+    virtual void detachDisplay(uint32_t displayIndex) final;
+
+    /**
+     * Check attachment status of the given display.
+     *
+     * \param displayIndex The display index
+     *
+     * \return true if the display is attached, false otherwise.
+     */
+    virtual bool isAttached(uint32_t displayIndex) final;
+    /**
+     * Displays the framebuffer content on the display.
+     *
+     * \param displayIndex The display index
+     */
+    virtual void display(uint32_t displayIndex) final;
+
+    /**
+     * Obtain backing store.
+     *
+     * The function activates the pDrv lock, to ensure consistency.
+     *
+     * \param displayIndex The display index
+     *
+     * \return Backing store information
+     */
+    virtual BackingStoreInfo acquireBackingStore(uint32_t displayIndex) final;
+
+    /**
+     * Release the backing store lock.
+     */
+    virtual void releaseBackingStore() final;
+
+    /**
+     * Take over the display driver from the default Graphics Adapter.
+     *
+     * \return VBox Status Code
+     */
+    int takeoverDriver();
+
+    /**
+     * Hand back the display driver to the default Graphics Adapter.
+     */
+    void handoverDriver();
+
+    /**
+     * Detach all attached displays.
+     */
+    void detachAllDisplays();
+
+private:
+    /**
+     * Update the screen data at the VBox Video Acceleration infrastructure for
+     * the desired display, including a resize, if necessary.
+     *
+     * \param displayIndex The desired display index
+     * \param fResetInputMapping Whether to reset the input mapping or not.
+     *
+     * \return VBox Status Code
+     */
+    int resizeVBVA(uint32_t displayIndex, bool fResetInputMapping);
+
+    /**
+     * Enable the VirtualBox Video Acceleration for the desired display.
+     *
+     * \param displayIndex The desired display index
+     *
+     *
+     * \return VBox Status Code
+     */
+    int enableVBVA(uint32_t displayIndex);
+
+    /**
+     * Disable the VirtualBox Video Acceleration for the desired display.
+     *
+     * \param displayIndex The desired display index
+     */
+    void disableVBVA(uint32_t displayIndex);
+
+    /**
+     * Check that all displays are detached.
+     *
+     * \return true if all displays are detached, false otherwise.
+     */
+    bool allDisplaysDetached();
+
+    /**
+     * The display internal management data structure
+     */
+    struct Display
+    {
+        VBVAINFOVIEW view;
+        VBVAINFOSCREEN screen;
+    };
+
+    PPDMDEVINS pDevIns;
+    unsigned iLUN;
+    PDMIBASE& iBase;
+    const uint32_t u32MonitorCount;
+
+    PPDMIDISPLAYCONNECTOR pDrv {nullptr};
+    PPDMIBASE pDrvBase {nullptr};
+
+    // Once we have taken over the display this get's true and stays true
+    // until guest reset or reboot.
+    bool ownDisplay {false};
+
+    std::vector<uint8_t> vram;
+    std::vector<Display> displays;
+
+    std::mutex driverMtx;
+    using DriverGuard = std::lock_guard<std::mutex>;
+};
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpuResource.hpp b/src/VBox/Devices/Graphics/DevVirtioGpuResource.hpp
new file mode 100644
index 0000000000..f27d57618f
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpuResource.hpp
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <vector>
+
+class VirtioGpuResource
+{
+    const uint32_t uResourceId_;
+    uint32_t uFormat_ {0};
+    uint32_t uWidth_ {0};
+    uint32_t uHeight_ {0};
+
+    uint32_t uScanoutId_ {0};
+
+public:
+    struct MemEntry
+    {
+        const uint64_t uAddr_; // guest physical address
+        const uint32_t uLength_;
+
+        MemEntry() = delete;
+        MemEntry(uint64_t uAddr, uint32_t uLength) : uAddr_(uAddr), uLength_(uLength) {}
+    };
+
+    static constexpr unsigned BYTES_PER_PIXEL {4u};
+
+private:
+    std::vector<MemEntry> vBacking_ {};
+
+public:
+    VirtioGpuResource() = delete;
+    VirtioGpuResource(uint32_t uResourceId) : uResourceId_(uResourceId) {}
+
+    ~VirtioGpuResource() = default;
+
+    uint32_t resourceId() const { return uResourceId_; }
+
+    void format(uint32_t uFormat) { uFormat_ = uFormat; }
+    uint32_t format() const { return uFormat_; }
+
+    void size(uint32_t uWidth, uint32_t uHeight)
+    {
+        uWidth_ = uWidth;
+        uHeight_ = uHeight;
+    }
+
+    uint32_t width() const { return uWidth_; }
+    uint32_t height() const { return uHeight_; }
+
+    void scanoutId(uint32_t uScanoutId) { uScanoutId_ = uScanoutId; }
+    uint32_t scanoutId() { return uScanoutId_; }
+
+    size_t memNeeded() const { return uWidth_ * uHeight_ * BYTES_PER_PIXEL; }
+
+    void reserveBacking(size_t sz) { vBacking_.reserve(sz); }
+    void clearBacking() { vBacking_.clear(); }
+    void addBacking(uint64_t uAddr, uint32_t uLenght) { vBacking_.emplace_back(uAddr, uLenght); }
+
+    MemEntry* getBacking(uint32_t idx) { return &vBacking_.at(idx); }
+    const std::vector<MemEntry>& getBacking() { return vBacking_; }
+};
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpuVBoxStubs.cpp b/src/VBox/Devices/Graphics/DevVirtioGpuVBoxStubs.cpp
new file mode 100644
index 0000000000..5a5d18c2e2
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpuVBoxStubs.cpp
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#define LOG_GROUP LOG_GROUP_DEV_VIRTIO_GPU
+#include "DevVirtioGpuVBoxStubs.hpp"
+#include "DevVirtioGpu.hpp"
+
+#include <VBox/log.h>
+#include <VBox/msi.h>
+#include <VBox/vmm/mm.h>
+#include <VBox/vmm/pdmdev.h>
+
+#ifdef IN_RING3
+#    include <iprt/uuid.h>
+#endif
+
+static DECLCALLBACK(int) devVirtioGpuConstruct(PPDMDEVINS pDevIns, int iInstance, PCFGMNODE pCfg)
+{
+    // Check that the device instance and device helper structures are compatible.
+    PDMDEV_CHECK_VERSIONS_RETURN(pDevIns);
+
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+
+    int rc {VINF_SUCCESS};
+    bool secondaryController {false};
+    unsigned cMonitorCount {0};
+    uint32_t u32VRamSize {0};
+
+    constexpr char validation[] = "secondaryController"
+                                  "|MonitorCount"
+                                  "|VRamSize";
+
+    PDMDEV_VALIDATE_CONFIG_RETURN(pDevIns, validation, "Invalid Configuration");
+
+    rc = pDevIns->pHlpR3->pfnCFGMQueryBoolDef(pCfg, "secondaryController", &secondaryController, false);
+    if (RT_FAILURE(rc)) {
+        return PDMDEV_SET_ERROR(pDevIns, rc,
+                                N_("Condfiguration error: Querying secondaryController asa a bool failed"));
+    }
+
+    rc = pDevIns->pHlpR3->pfnCFGMQueryU32Def(pCfg, "MonitorCount", &cMonitorCount, 1);
+    if (RT_FAILURE(rc)) {
+        return PDMDEV_SET_ERROR(pDevIns, rc, N_("Configuration error: Querying MonitorCount as uint32_t failed"));
+    }
+
+    rc = pDevIns->pHlpR3->pfnCFGMQueryU32Def(pCfg, "VRamSize", &u32VRamSize, 32 * _1M);
+    if (RT_FAILURE(rc)) {
+        return PDMDEV_SET_ERROR(pDevIns, rc, N_("Configuration error: Querying VRAM Size as uin32_t failed"));
+    }
+
+    rc = pThis->init(pDevIns, iInstance, u32VRamSize, cMonitorCount, secondaryController);
+    AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) devVirtioGpuDestruct(PPDMDEVINS pDevIns)
+{
+    // Check that the device instance and device helper structures are compatible again.
+    PDMDEV_CHECK_VERSIONS_RETURN(pDevIns);
+
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+
+    int rc {pThis->terminate(pDevIns)};
+    AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(void) devVirtioGpuReset(PPDMDEVINS pDevIns)
+{
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+    pThis->pDisplayManager->reset();
+    pThis->pDisplayManager->handoverDriver();
+}
+
+static DECLCALLBACK(int) devVirtioGpuAttach(PPDMDEVINS pDevIns, unsigned iLUN, uint32_t)
+{
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+
+    /* we only support iLUN == 0 at the moment */
+    if (iLUN != 0) {
+        AssertLogRelMsgFailed(("Invalid LUN #%d\n", iLUN));
+        return VERR_PDM_NO_SUCH_LUN;
+    }
+
+    int rc {pThis->pDisplayManager->takeoverDriver()};
+    AssertLogRelReturn(RT_SUCCESS(rc), rc);
+
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(void) devVirtioGpuDetach(PPDMDEVINS pDevIns, unsigned, uint32_t)
+{
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+    pThis->pDisplayManager->detachAllDisplays();
+}
+
+/**
+ * Device registration structure.
+ */
+extern "C" const PDMDEVREG g_DeviceVirtioGpuDev = {
+    /* .u32Version = */ PDM_DEVREG_VERSION,
+    /* .uReserved0 = */ 0,
+    /* .szName = */ "virtio-gpu",
+    /* .fFlags = */ PDM_DEVREG_FLAGS_DEFAULT_BITS | PDM_DEVREG_FLAGS_NEW_STYLE,
+    /* .fClass = */ PDM_DEVREG_CLASS_GRAPHICS,
+    /* .cMaxInstances = */ 1u,
+    /* .uSharedVersion = */ 42,
+    /* .cbInstanceShared = */ sizeof(VIRTIOGPUDEV),
+    /* .cbInstanceR0 = */ sizeof(VIRTIOGPUDEVCC),
+    /* .cbInstanceRC = */ 0,
+    /* .cMaxPciDevices = */ 1,
+    /* .cMaxMsixVectors = */ VBOX_MSIX_MAX_ENTRIES,
+    /* .pszDescription = */ "Virtio Host GPU.\n",
+    /* .pszRCMod = */ "",
+    /* .pszR0Mod = */ "",
+    /* .pfnConstruct = */ devVirtioGpuConstruct,
+    /* .pfnDestruct = */ devVirtioGpuDestruct,
+    /* .pfnRelocate = */ NULL,
+    /* .pfnMemSetup = */ NULL,
+    /* .pfnPowerOn = */ NULL,
+    /* .pfnReset = */ devVirtioGpuReset,
+    /* .pfnSuspend = */ NULL,
+    /* .pfnResume = */ NULL,
+    /* .pfnAttach = */ devVirtioGpuAttach,
+    /* .pfnDetach = */ devVirtioGpuDetach,
+    /* .pfnQueryInterface. = */ NULL,
+    /* .pfnInitComplete = */ NULL,
+    /* .pfnPowerOff = */ NULL,
+    /* .pfnSoftReset = */ NULL,
+    /* .pfnReserved0 = */ NULL,
+    /* .pfnReserved1 = */ NULL,
+    /* .pfnReserved2 = */ NULL,
+    /* .pfnReserved3 = */ NULL,
+    /* .pfnReserved4 = */ NULL,
+    /* .pfnReserved5 = */ NULL,
+    /* .pfnReserved6 = */ NULL,
+    /* .pfnReserved7 = */ NULL,
+    /* .u32VersionEnd = */ PDM_DEVREG_VERSION};
+
+DECLCALLBACK(void) virtioGpuStatusChanged(PVIRTIOCORE pVirtio, PVIRTIOCORECC, uint32_t fDriverOk)
+{
+    PVIRTIOGPUDEV pThis {RT_FROM_MEMBER(pVirtio, VIRTIOGPUDEV, virtio)};
+
+    if (fDriverOk != 0) {
+        int rc = pThis->start();
+        AssertLogRel(RT_SUCCESS(rc));
+    } else {
+        int rc = pThis->stop();
+        AssertLogRel(RT_SUCCESS(rc));
+    }
+}
+
+DECLCALLBACK(int) virtioGpuDevCapRead(PPDMDEVINS pDevIns, uint32_t uOffset, void* pvBuf, uint32_t cbToRead)
+{
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+    return pThis->readCap(uOffset, pvBuf, cbToRead);
+}
+
+DECLCALLBACK(int) virtioGpuDevCapWrite(PPDMDEVINS pDevIns, uint32_t uOffset, const void* pvBuf, uint32_t cbToWrite)
+{
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+    return pThis->writeCap(uOffset, pvBuf, cbToWrite);
+}
+
+DECLCALLBACK(void) virtioGpuVirtqNotified(PPDMDEVINS pDevIns, PVIRTIOCORE, uint16_t uVirtqNbr)
+{
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+    pThis->wakeupWorker(uVirtqNbr);
+}
+
+DECLCALLBACK(void)
+virtioGpuDisplayChanged(PPDMDEVINS pDevIns, uint32_t numDisplays, VMMDevDisplayDef* displayDefs)
+{
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+    pThis->displayChanged(numDisplays, displayDefs);
+}
+
+DECLCALLBACK(void*) virtioGpuQueryInterface(PPDMIBASE pInterface, const char* pszIID)
+{
+    PPDMDEVINS pDevIns {PDMIBASE_2_PDMDEV(pInterface)};
+    PVIRTIOGPUDEV pThis {PDMDEVINS_2_DATA(pDevIns, PVIRTIOGPUDEV)};
+    LogRel8(("%s: virtioGpuQueryInterface.\n", pThis->szInst.c_str()));
+    PDMIBASE_RETURN_INTERFACE(pszIID, PDMIVIRTIOGPUPORT, &pThis->IVirtioGpuPort);
+    return nullptr;
+}
+
+DECLCALLBACK(void*) virtioGpuPortQueryInterface(PPDMIBASE pInterface, const char* pszIID)
+{
+    PVIRTIOGPUDEV pThis {RT_FROM_MEMBER(pInterface, VIRTIOGPUDEV, IBase)};
+    LogRel8(("%s: virtioGpuPortQueryInterface.\n", pThis->szInst.c_str()));
+    PDMIBASE_RETURN_INTERFACE(pszIID, PDMIBASE, &pThis->IBase);
+    PDMIBASE_RETURN_INTERFACE(pszIID, PDMIDISPLAYPORT, &pThis->IPort);
+    PDMIBASE_RETURN_INTERFACE(pszIID, PDMIDISPLAYVBVACALLBACKS, &pThis->IVBVACallbacks);
+    return nullptr;
+}
+
+static PVIRTIOGPUDEV virtioGpuFromPPDMIDISPLAYPORT(PPDMIDISPLAYPORT pInterface)
+{
+    return reinterpret_cast<PVIRTIOGPUDEV>(reinterpret_cast<uintptr_t>(pInterface) - RT_OFFSETOF(VIRTIOGPUDEV, IPort));
+}
+
+DECLCALLBACK(void) virtioGpuPortSetRenderVRAM(PPDMIDISPLAYPORT pInterface, bool)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuPortSetRenderVRAM.\n", pThis->szInst.c_str()));
+}
+
+DECLCALLBACK(int) virtioGpuUpdateDisplay(PPDMIDISPLAYPORT pInterface)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuUpdateDisplay.\n", pThis->szInst.c_str()));
+    return VINF_SUCCESS;
+}
+
+DECLCALLBACK(int) virtioGpuPortUpdateDisplayAll(PPDMIDISPLAYPORT pInterface, bool)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuPortUpdateDisplayAll.\n", pThis->szInst.c_str()));
+    return VINF_SUCCESS;
+}
+
+DECLCALLBACK(int)
+virtioGpuPortQueryVideoMode(PPDMIDISPLAYPORT pInterface, uint32_t* pcBits, uint32_t* pcx, uint32_t* pcy)
+{
+    PVIRTIOGPUDEV pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuPortQueryVideoMode. pcBits: %u, pcx: %u, pcy: %u.\n", pThis->szInst.c_str(), *pcBits, *pcx,
+             *pcy));
+
+    if (!pcBits) {
+        return VERR_INVALID_PARAMETER;
+    }
+
+    *pcBits = 0;
+
+    // CYBER-TODO: This should not always be scanout 0
+    // When we have figured out how to handle multiple VBox-Windows, we have to
+    // figure out how to get the index of the scanout here.
+    auto maybeScanout {pThis->pCmdHandler->getCScanout(0)};
+    if (not maybeScanout.has_value()) {
+        return VINF_SUCCESS;
+    }
+
+    const auto currentScanout {maybeScanout->get()};
+    if (pcx) {
+        *pcx = currentScanout.uCurrentWidth;
+    }
+
+    if (pcy) {
+        *pcy = currentScanout.uCurrentHeight;
+    }
+
+    return VINF_SUCCESS;
+}
+
+DECLCALLBACK(int) virtioGpuPortSetRefreshRate(PPDMIDISPLAYPORT pInterface, uint32_t)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuPortSetRefreshRate.\n", pThis->szInst.c_str()));
+    return VINF_SUCCESS;
+}
+
+DECLCALLBACK(int) virtioGpuPortTakeScreenshot(PPDMIDISPLAYPORT pInterface, uint8_t**, size_t*, uint32_t*, uint32_t*)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuPortTakeScreenshot.\n", pThis->szInst.c_str()));
+    return VINF_SUCCESS;
+}
+
+DECLCALLBACK(void) virtioGpuPortFreeScreenshot(PPDMIDISPLAYPORT pInterface, uint8_t*)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuPortFreeScreenshot.\n", pThis->szInst.c_str()));
+}
+
+DECLCALLBACK(void) virtioGpuPortUpdateDisplayRect(PPDMIDISPLAYPORT pInterface, int32_t, int32_t, uint32_t, uint32_t)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuPortUpdateDisplayRect.\n", pThis->szInst.c_str()));
+}
+
+DECLCALLBACK(int)
+virtioGpuPortDisplayBlt(PPDMIDISPLAYPORT pInterface, const void*, uint32_t, uint32_t, uint32_t, uint32_t)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuPortDisplayBlt.\n", pThis->szInst.c_str()));
+    return VINF_SUCCESS;
+}
+
+DECLCALLBACK(int)
+virtioGpuPortCopyRect(PPDMIDISPLAYPORT pInterface, uint32_t, uint32_t, const uint8_t*, int32_t, int32_t, uint32_t,
+                      uint32_t, uint32_t, uint32_t, uint8_t*, int32_t, int32_t, uint32_t, uint32_t, uint32_t, uint32_t)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: virtioGpuPortCopyRect.\n", pThis->szInst.c_str()));
+    return VINF_SUCCESS;
+}
+
+DECLCALLBACK(void)
+vmsvgavirtioGpuPortSetViewport(PPDMIDISPLAYPORT pInterface, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: SetViewport\n\n\n\n\n", pThis->szInst.c_str()));
+}
+
+DECLCALLBACK(int)
+vbvavirtioGpuPortSendModeHint(PPDMIDISPLAYPORT pInterface, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t,
+                              uint32_t, uint32_t)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: vbvavirtioGpuPortSendModeHint.\n", pThis->szInst.c_str()));
+    return VINF_SUCCESS;
+}
+
+DECLCALLBACK(void) vbvavirtioGpuPortReportHostCursorCapabilities(PPDMIDISPLAYPORT pInterface, bool, bool)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: vbvavirtioGpuPortReportHostCursorCapabilities.\n", pThis->szInst.c_str()));
+}
+
+DECLCALLBACK(void) vbvavirtioGpuPortReportHostCursorPosition(PPDMIDISPLAYPORT pInterface, uint32_t, uint32_t, bool)
+{
+    [[maybe_unused]] auto pThis {virtioGpuFromPPDMIDISPLAYPORT(pInterface)};
+    LogRel8(("%s: vbvavirtioGpuPortReportHostCursorPosition.\n", pThis->szInst.c_str()));
+}
diff --git a/src/VBox/Devices/Graphics/DevVirtioGpuVBoxStubs.hpp b/src/VBox/Devices/Graphics/DevVirtioGpuVBoxStubs.hpp
new file mode 100644
index 0000000000..fd6a56241c
--- /dev/null
+++ b/src/VBox/Devices/Graphics/DevVirtioGpuVBoxStubs.hpp
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#pragma once
+
+#include <VBox/VMMDev.h>
+#include <VBox/vmm/pdmdev.h>
+
+#include "../VirtIO/VirtioCore.h"
+
+#include <cstdint>
+
+/*
+ * VIRTIOCORER3
+ */
+
+/** VIRTIOCORER3::pfnStatusChanged */
+DECLCALLBACK(void) virtioGpuStatusChanged(PVIRTIOCORE pVirtio, PVIRTIOCORECC, uint32_t fDriverOk);
+
+/** VIRTIOCORER3::pfnDevCapRead */
+DECLCALLBACK(int) virtioGpuDevCapRead(PPDMDEVINS pDevIns, uint32_t uOffset, void* pvBuf, uint32_t cbToRead);
+
+/** VIRTIOCORER3::pfnDevCapWrite */
+DECLCALLBACK(int) virtioGpuDevCapWrite(PPDMDEVINS pDevIns, uint32_t uOffset, const void* pvBuf, uint32_t cbToWrite);
+
+/** VIRTIOCORER3::pfnVirtqNotified */
+DECLCALLBACK(void) virtioGpuVirtqNotified(PPDMDEVINS pDevIns, PVIRTIOCORE, uint16_t uVirtqNbr);
+
+DECLCALLBACK(void)
+virtioGpuDisplayChanged(PPDMDEVINS pDevIns, uint32_t numDisplays, VMMDevDisplayDef* displayDefs);
+
+DECLCALLBACK(void*) virtioGpuQueryInterface(PPDMIBASE pInterface, const char* pszIID);
+
+DECLCALLBACK(void) virtioGpuReset(PPDMDEVINS);
+DECLCALLBACK(int) virtioGpuAttach(PPDMDEVINS, unsigned, uint32_t);
+DECLCALLBACK(void) virtioGpuDetach(PPDMDEVINS, unsigned, uint32_t);
+DECLCALLBACK(void*) virtioGpuPortQueryInterface(PPDMIBASE, const char*);
+DECLCALLBACK(void) virtioGpuPortSetRenderVRAM(PPDMIDISPLAYPORT, bool);
+DECLCALLBACK(int) virtioGpuUpdateDisplay(PPDMIDISPLAYPORT);
+DECLCALLBACK(int) virtioGpuPortUpdateDisplayAll(PPDMIDISPLAYPORT, bool);
+DECLCALLBACK(int) virtioGpuPortQueryVideoMode(PPDMIDISPLAYPORT, uint32_t*, uint32_t*, uint32_t*);
+DECLCALLBACK(int) virtioGpuPortSetRefreshRate(PPDMIDISPLAYPORT, uint32_t);
+DECLCALLBACK(int) virtioGpuPortTakeScreenshot(PPDMIDISPLAYPORT, uint8_t**, size_t*, uint32_t*, uint32_t*);
+DECLCALLBACK(void) virtioGpuPortFreeScreenshot(PPDMIDISPLAYPORT, uint8_t*);
+DECLCALLBACK(void) virtioGpuPortUpdateDisplayRect(PPDMIDISPLAYPORT, int32_t, int32_t, uint32_t, uint32_t);
+DECLCALLBACK(int) virtioGpuPortDisplayBlt(PPDMIDISPLAYPORT, const void*, uint32_t, uint32_t, uint32_t, uint32_t);
+DECLCALLBACK(int)
+virtioGpuPortCopyRect(PPDMIDISPLAYPORT, uint32_t, uint32_t, const uint8_t*, int32_t, int32_t, uint32_t, uint32_t,
+                      uint32_t, uint32_t, uint8_t*, int32_t, int32_t, uint32_t, uint32_t, uint32_t, uint32_t);
+DECLCALLBACK(void) vmsvgavirtioGpuPortSetViewport(PPDMIDISPLAYPORT, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t);
+DECLCALLBACK(int)
+vbvavirtioGpuPortSendModeHint(PPDMIDISPLAYPORT, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t,
+                              uint32_t);
+DECLCALLBACK(void) vbvavirtioGpuPortReportHostCursorCapabilities(PPDMIDISPLAYPORT, bool, bool);
+DECLCALLBACK(void) vbvavirtioGpuPortReportHostCursorPosition(PPDMIDISPLAYPORT, uint32_t, uint32_t, bool);
diff --git a/src/VBox/Devices/Makefile.kmk b/src/VBox/Devices/Makefile.kmk
index d2bef9129d..a4caa91016 100644
--- a/src/VBox/Devices/Makefile.kmk
+++ b/src/VBox/Devices/Makefile.kmk
@@ -197,6 +197,10 @@ if !defined(VBOX_ONLY_EXTPACKS) && "$(intersects $(KBUILD_TARGET_ARCH),$(VBOX_SU
  	EFI/DevFlash.cpp \
  	EFI/FlashCore.cpp \
  	Graphics/DevVGA.cpp \
+	Graphics/DevVirtioGpuCmdHandler.cpp \
+	Graphics/DevVirtioGpu.cpp \
+	Graphics/DevVirtioGpuDisplayManager.cpp \
+	Graphics/DevVirtioGpuVBoxStubs.cpp \
  	Storage/DevATA.cpp \
  	PC/DevPit-i8254.cpp \
  	PC/DevPIC.cpp \
@@ -259,6 +263,12 @@ if !defined(VBOX_ONLY_EXTPACKS) && "$(intersects $(KBUILD_TARGET_ARCH),$(VBOX_SU
  Bus/DevVfio.cpp_CXXFLAGS.linux += $(CYBERUS_CXX_FLAGS)
  Bus/VfioDevice.cpp_CXXFLAGS.linux += $(CYBERUS_CXX_FLAGS)
 
+ # VirtioGPU
+ VBoxDD_DEFS += $(VMM_COMMON_DEFS)
+ Graphics/DevVirtioGpuCmdHandler.cpp_CXXFLAGS.linux += $(CYBERUS_CXX_FLAGS)
+ Graphics/DevVirtioGpu.cpp_CXXFLAGS.linux += $(CYBERUS_CXX_FLAGS)
+ Graphics/DevVirtioGpuVBoxStubs.cpp_CXXFLAGS.linux += $(CYBERUS_CXX_FLAGS)
+
  ifn1of ($(KBUILD_TARGET), darwin)
   VBoxDD_SOURCES += Storage/HBDMgmt-generic.cpp
  endif
diff --git a/src/VBox/Devices/VirtIO/VirtioCore.cpp b/src/VBox/Devices/VirtIO/VirtioCore.cpp
index 3849aa7cbe..8abd7619ba 100644
--- a/src/VBox/Devices/VirtIO/VirtioCore.cpp
+++ b/src/VBox/Devices/VirtIO/VirtioCore.cpp
@@ -1272,7 +1272,7 @@ static int virtioNudgeGuest(PPDMDEVINS pDevIns, PVIRTIOCORE pVirtio, uint8_t uCa
 
     if (!pVirtio->fMsiSupport)
     {
-        pVirtio->uISR |= uCause;
+        pVirtio->uISR = (VIRTIO_ISR_DEVICE_CONFIG == uCause) ? 0x3 : uCause;
         PDMDevHlpPCISetIrq(pDevIns, 0, PDM_IRQ_LEVEL_HIGH);
     }
     else if (uMsixVector != VIRTIO_MSI_NO_VECTOR)
diff --git a/src/VBox/Devices/build/VBoxDD.cpp b/src/VBox/Devices/build/VBoxDD.cpp
index d601e45546..e7497c649f 100644
--- a/src/VBox/Devices/build/VBoxDD.cpp
+++ b/src/VBox/Devices/build/VBoxDD.cpp
@@ -250,6 +250,9 @@ extern "C" DECLEXPORT(int) VBoxDevicesRegister(PPDMDEVREGCB pCallbacks, uint32_t
     if (RT_FAILURE(rc))
         return rc;
 #endif
+    rc = pCallbacks->pfnRegister(pCallbacks, &g_DeviceVirtioGpuDev);
+    if (RT_FAILURE(rc))
+        return rc;
 
     return VINF_SUCCESS;
 }
diff --git a/src/VBox/Devices/build/VBoxDD.h b/src/VBox/Devices/build/VBoxDD.h
index d208ea1e7f..63dedfaa64 100644
--- a/src/VBox/Devices/build/VBoxDD.h
+++ b/src/VBox/Devices/build/VBoxDD.h
@@ -109,6 +109,7 @@ extern const PDMDEVREG g_DevicePciRaw;
 #endif
 extern const PDMDEVREG g_DeviceVfioDev;
 extern const PDMDEVREG g_DeviceGIMDev;
+extern const PDMDEVREG g_DeviceVirtioGpuDev;
 extern const PDMDEVREG g_DeviceLPC;
 #ifdef VBOX_WITH_VIRTUALKD
 extern const PDMDEVREG g_DeviceVirtualKD;
diff --git a/src/VBox/Devices/testcase/Makefile.kmk b/src/VBox/Devices/testcase/Makefile.kmk
index a65768b802..288199e3bc 100644
--- a/src/VBox/Devices/testcase/Makefile.kmk
+++ b/src/VBox/Devices/testcase/Makefile.kmk
@@ -70,12 +70,18 @@ ifeq ($(KBUILD_TARGET),$(KBUILD_HOST))
  ifeq ($(filter-out x86.x86 amd64.amd64 x86.amd64, $(KBUILD_TARGET_ARCH).$(KBUILD_HOST_ARCH)),)
   OTHERS += \
   	$(VBOX_DEVICES_TEST_OUT_DIR)/tstDeviceStructSize.run
+  if defined(VBOX_WITH_SUPERNOVA_UNITTESTS)
+	OTHERS += $(VBOX_DEVICES_TEST_OUT_DIR)/tstVirtioGpuCmdHandling.run
+  endif
  endif
 endif
 
 # The normal testing pass.
-TESTING += \
-	$(VBOX_DEVICES_TEST_OUT_DIR)/tstDeviceStructSize.run
+TESTING += $(VBOX_DEVICES_TEST_OUT_DIR)/tstDeviceStructSize.run
+
+if defined(VBOX_WITH_SUPERNOVA_UNITTESTS)
+	TESTING += $(VBOX_DEVICES_TEST_OUT_DIR)/tstVirtioGpuCmdHandling.run
+endif
 
 ifdef VBOX_WITH_RAW_MODE
  #
@@ -128,6 +134,27 @@ ifdef VBOX_WITH_RAW_MODE
 endif
 tstDeviceStructSize_INCS      += $(VBOX_PATH_VMM_DEVICES_SRC)
 
+if defined(VBOX_WITH_SUPERNOVA_UNITTESTS)
+PROGRAMS += tstVirtioGpuCmdHandling
+endif
+
+tstVirtioGpuCmdHandling_TEMPLATE = VBOXR3AUTOTST
+tstVirtioGpuCmdHandling_DEFS     = $(VBOX_DEVICES_TESTS_FEATURES)
+tstVirtioGpuCmdHandling_INCS     = \
+	$(VBOX_PATH_DEVICES_SRC)/build \
+	$(VBOX_PATH_DEVICES_SRC)/Bus \
+	$(VBOX_DEVICES_TEST_OUT_DIR) \
+	$(VBOX_GRAPHICS_INCS) \
+	$(VBoxDD_INCS)
+tstVirtioGpuCmdHandling_SOURCES  = \
+	../Graphics/DevVirtioGpuCmdHandler.cpp \
+	tstVirtioGpuCmdHandling.cpp
+tstVirtioGpuCmdHandling_LIBS    = \
+	$(VBOX_LIB_RUNTIME_STATIC)
+tstVirtioGpuCmdHandling_CLEAN    = \
+	$(VBOX_DEVICES_TEST_OUT_DIR)/tstVirtioGpuCmdHandling.run
+tstVirtioGpuCmdHandling_INCS     += $(VBOX_PATH_VMM_DEVICES_SRC)
+
 #
 # Run rule for tstDeviceStructSize.
 #
@@ -149,8 +176,14 @@ $(VBOX_DEVICES_TEST_OUT_DIR)/tstDeviceStructSize.run: $$(tstDeviceStructSize_1_S
 	$^
 	$(QUIET)$(APPEND) "$@" "done"
 
+$(VBOX_DEVICES_TEST_OUT_DIR)/tstVirtioGpuCmdHandling.run: $$(tstVirtioGpuCmdHandling_1_STAGE_TARGET) | $$(dir $$@)
+	$(QUIET)$(RM) -f $@
+	$^
+	$(QUIET)$(APPEND) "$@" "done"
+
 # alias for the struct test.
 run-struct-tests: $(VBOX_DEVICES_TEST_OUT_DIR)/tstDeviceStructSize.run
+run-supernova-tests: $(VBOX_DEVICES_TEST_OUT_DIR)/tstVirtioGpuCmdHandling.run
 
 
 include $(FILE_KBUILD_SUB_FOOTER)
diff --git a/src/VBox/Devices/testcase/tstVirtioGpuAdapter.hpp b/src/VBox/Devices/testcase/tstVirtioGpuAdapter.hpp
new file mode 100644
index 0000000000..9e23a733cf
--- /dev/null
+++ b/src/VBox/Devices/testcase/tstVirtioGpuAdapter.hpp
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#include "../Graphics/DevVirtioGpuCmdHandler.hpp"
+
+#include <catch2/catch.hpp>
+
+#include <array>
+#include <cstdlib>
+#include <numeric>
+#include <tuple>
+#include <vector>
+
+static constexpr uint32_t TST_VIOGPU_MAX_SCANOUTS {2u};
+
+class tstVirtioAdapter final : public VirtioGpuCmdHandler::VirtioAdapter
+{
+public:
+    uint8_t* sendBuf_ {nullptr}; // During each virtqBufDrain, we will read from this pointer into pv
+    uint8_t* recvBuf_ {nullptr}; // During each virtqBufPut, we will write to this pointer
+
+    template <typename SendType, typename ReceiveType>
+    void prepareCommand(SendType* send, ReceiveType* recv, uint16_t uVirtq, PVIRTQBUF pVirtqBuf)
+    {
+        prepareCommand(send, sizeof(SendType), recv, sizeof(ReceiveType), uVirtq, pVirtqBuf);
+    }
+
+    void prepareCommand(void* sendBuf, size_t sendSz, void* recvBuf, size_t recvSz, uint16_t uVirtq, PVIRTQBUF pVirtqBuf)
+    {
+        sendBuf_ = reinterpret_cast<uint8_t*>(sendBuf);
+        pVirtqBuf->cbPhysSend = sendSz;
+        recvBuf_ = reinterpret_cast<uint8_t*>(recvBuf);
+        pVirtqBuf->cbPhysReturn = recvSz;
+        pVirtqBuf->uVirtq = uVirtq;
+    }
+
+    void virtqBufDrain(PVIRTQBUF pVirtqBuf, void *pv, size_t cb) final
+    {
+        REQUIRE(pVirtqBuf != nullptr);
+        REQUIRE(pv != nullptr);
+        REQUIRE(cb != 0);
+
+        // The cmdHandler has to check wether the size of the src buffer is sufficient for the drain-request
+        REQUIRE(pVirtqBuf->cbPhysSend >= cb);
+        std::memcpy(pv, sendBuf_, cb);
+        pVirtqBuf->cbPhysSend -= cb;
+        sendBuf_ += cb;
+    }
+
+    void virtqBufPut(PVIRTQBUF pVirtqBuf, void *pv, size_t cb) final
+    {
+        REQUIRE(pVirtqBuf != nullptr);
+        REQUIRE(pv != nullptr);
+        REQUIRE(cb != 0);
+
+        // The cmdHandler has to check wether the size of the dst buffer is sufficient for the put-request
+        REQUIRE(pVirtqBuf->cbPhysReturn >= cb);
+        std::memcpy(recvBuf_, pv, cb);
+        pVirtqBuf->cbPhysReturn -= cb;
+        recvBuf_ += cb;
+    }
+
+    void virtqSyncRings(PVIRTQBUF pVirtqBuf) final
+    {
+        REQUIRE(pVirtqBuf != 0);
+    }
+};
+
+class tstDisplayAdapter final : public VirtioGpuCmdHandler::displayAdapter
+{
+public:
+    std::vector<uint8_t> framebuf;
+    uint32_t displayIdx {0};
+    bool fAttached {false};
+    bool fFlushed  {false};
+    uint32_t uCurrentWidth {virtioGpu::INITIAL_WIDTH};
+    uint32_t uCurrentHeight {virtioGpu::INITIAL_HEIGHT};
+
+    tstDisplayAdapter() = default;
+
+    void reset()
+    {
+        framebuf.clear();
+        fAttached = false;
+        fFlushed = false;
+        uCurrentWidth = virtioGpu::INITIAL_WIDTH;
+        uCurrentHeight = virtioGpu::INITIAL_HEIGHT;
+    }
+
+    void resize(uint32_t uWidth, uint32_t uHeight) final
+    {
+        uCurrentWidth = uWidth;
+        uCurrentHeight = uHeight;
+
+        framebuf.resize(cbFrameBuffer());
+    }
+
+    std::tuple<uint32_t, uint32_t> size() final
+    {
+        return std::make_tuple(uCurrentWidth, uCurrentHeight);
+    }
+
+    void attachDisplay(unsigned iLUN) final
+    {
+        REQUIRE(iLUN == displayIdx);
+        fAttached = true;
+    }
+
+    void detachDisplay(unsigned iLUN) final
+    {
+        REQUIRE(iLUN == displayIdx);
+        fAttached = false;
+    }
+
+    bool isAttachedToDisplay() final
+    {
+        return fAttached;
+    }
+
+    void flush(uint32_t /*uWidth*/, uint32_t /*uHeight*/) final
+    {
+        fFlushed = true;
+    }
+
+    void* pFrameBuffer() final { return framebuf.data(); }
+    size_t cbFrameBuffer() final { return uCurrentWidth * uCurrentHeight * virtioGpuResource::BYTES_PER_PIXEL; }
+};
+
+class tstDisplayManager final : public VirtioGpuCmdHandler::DisplayManager
+{
+    std::array<tstDisplayAdapter, TST_VIOGPU_MAX_SCANOUTS> displayAdapters;
+public:
+    tstDisplayManager()
+    {
+        uint32_t displayIdx {0u};
+        for (auto& displayAdapterOne : displayAdapters) {
+            displayAdapterOne.displayIdx = displayIdx;
+            displayIdx++;
+        }
+    }
+
+    tstDisplayAdapter* display(uint32_t idx) final
+    {
+        if (idx > TST_VIOGPU_MAX_SCANOUTS-1) {
+            return nullptr;
+        }
+        return &displayAdapters.at(idx);
+    }
+};
+
+class tstMemoryAdapter final : public VirtioGpuCmdHandler::MemoryAdapter
+{
+public:
+    VecMappings mapGCPhys2HCVirt(const vecMemEntries& vBacking) final
+    {
+        vecMappings vMapping;
+        for (const auto& backing : vBacking) {
+            void* uAddr {reinterpret_cast<void*>(backing.uAddr_)};
+            vMapping.emplace_back(uAddr, backing.uLength_, nullptr);
+        }
+        return vMapping;
+    }
+
+    void releaseMappings(const vecMappings& /*vMapping*/) final { return ; }
+};
diff --git a/src/VBox/Devices/testcase/tstVirtioGpuCmdHandling.cpp b/src/VBox/Devices/testcase/tstVirtioGpuCmdHandling.cpp
new file mode 100644
index 0000000000..a10d4e1aaf
--- /dev/null
+++ b/src/VBox/Devices/testcase/tstVirtioGpuCmdHandling.cpp
@@ -0,0 +1,450 @@
+/*
+ * Copyright (C) Cyberus Technology GmbH.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * SPDX-License-Identifier: GPL-3.0-or-later
+ */
+
+#include <VBox/types.h>
+#include <VBox/vmm/pdmdev.h>
+#include <VBox/vmm/stam.h>
+
+#define CATCH_CONFIG_MAIN
+#include <catch2/catch.hpp>
+
+#undef LOG_GROUP
+#include "../Graphics/DevVirtioGpuDefinitions.hpp"
+#include "../Graphics/DevVirtioGpuCmdHandler.hpp"
+#include "tstVirtioGpuAdapter.hpp"
+
+#include <algorithm>
+
+// virtioAdapter and memoryAdapter both have no state, thus we can reuse them
+static tstVirtioAdapter virtioAdapter;
+static tstMemoryAdapter memoryAdapter;
+
+static VIRTQBUF virtqBuf;
+
+static constexpr uint32_t RESOURCE_ID_ONE {1u};
+static constexpr uint32_t RESOURCE_ID_TWO {2u};
+
+static constexpr uint32_t SCANOUT_ID_ONE {0u};
+static constexpr uint32_t SCANOUT_ID_TWO {1u};
+
+static constexpr uint32_t RESOURCE_WIDTH {1920u};
+static constexpr uint32_t RESOURCE_HEIGHT {1080u};
+static constexpr uint32_t RESIZED_WIDTH {800u};
+static constexpr uint32_t RESIZED_HEIGHT {600u};
+
+static constexpr uint32_t NUM_BACKINGS {4u};
+static constexpr size_t BACKING_SIZE {X86_PAGE_SIZE};
+static constexpr size_t SIZE_FRAMEBUFFER {NUM_BACKINGS * BACKING_SIZE};
+
+static constexpr size_t ATTACH_BACKING_STRUCT_SIZE {sizeof(virtioGpu::resourceAttachBacking) + NUM_BACKINGS * sizeof(virtioGpu::resourceMemEntry)};
+
+TEST_CASE("handler returns out-of-memory error if request-buffer is too small")
+{
+    tstDisplayManager displayManager;
+    VirtioGpuCmdHandler handler(virtioAdapter, displayManager, memoryAdapter, TST_VIOGPU_MAX_SCANOUTS, false);
+    virtioGpu::ctrlHdr recvHdr;
+
+    virtqBuf.cbPhysReturn = sizeof(recvHdr);
+    virtqBuf.uVirtq = virtioGpu::virtqIdx::CONTROLQ;
+    virtioAdapter.recvBuf_ = reinterpret_cast<uint8_t *>(&recvHdr);
+
+    handler.handleBuffer(&virtqBuf);
+    REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::ERR_OUT_OF_MEMORY);
+}
+
+TEST_CASE("handler returns unspec error if the ctrl-type is unknown")
+{
+    tstDisplayManager displayManager;
+    VirtioGpuCmdHandler handler(virtioAdapter, displayManager, memoryAdapter, TST_VIOGPU_MAX_SCANOUTS, false);
+    virtioGpu::ctrlHdr recvHdr;
+
+    // GET_DISPLAY_INFO is the command with the lowest value, thus GET_DISPLAY_INFO is an invalid command.
+    virtioGpu::ctrlHdr sendHdr {virtioGpu::ctrlType::cmd::GET_DISPLAY_INFO - 1};
+
+    virtioAdapter.prepareCommand(&sendHdr, &recvHdr, virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+    handler.handleBuffer(&virtqBuf);
+    REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::ERR_UNSPEC);
+}
+
+TEST_CASE("handler returns unspec error if a command is in the wrong queue")
+{
+    tstDisplayManager displayManager;
+    VirtioGpuCmdHandler handler(virtioAdapter, displayManager, memoryAdapter, TST_VIOGPU_MAX_SCANOUTS, false);
+
+    for (uint32_t cmd {virtioGpu::ctrlType::cmd::GET_DISPLAY_INFO}; cmd < virtioGpu::ctrlType::cmd::RESOURCE_DETACH_BACKING; cmd++) {
+        virtioGpu::ctrlHdr sendHdr {cmd};
+        virtioGpu::ctrlHdr recvHdr;
+        virtioAdapter.prepareCommand(&sendHdr, &recvHdr, virtioGpu::virtqIdx::CURSORQ, &virtqBuf);
+        handler.handleBuffer(&virtqBuf);
+        REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::ERR_UNSPEC);
+    }
+
+    {
+        virtioGpu::ctrlHdr sendHdr {virtioGpu::ctrlType::cmd::GET_EDID};
+        virtioGpu::ctrlHdr recvHdr;
+        virtioAdapter.prepareCommand(&sendHdr, &recvHdr, virtioGpu::virtqIdx::CURSORQ, &virtqBuf);
+        handler.handleBuffer(&virtqBuf);
+        REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::ERR_UNSPEC);
+    }
+
+    for (uint32_t cmd {virtioGpu::ctrlType::cmd::UPDATE_CURSOR}; cmd < virtioGpu::ctrlType::cmd::MOVE_CURSOR; cmd++) {
+        virtioGpu::ctrlHdr sendHdr {cmd};
+        virtioGpu::ctrlHdr recvHdr;
+        virtioAdapter.prepareCommand(&sendHdr, &recvHdr, virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+        handler.handleBuffer(&virtqBuf);
+        REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::ERR_UNSPEC);
+    }
+}
+
+SCENARIO("The command handler respects the attachDisplayLater flag")
+{
+    GIVEN("A display adapter and a GET_DISPLAY_INFO command") {
+        tstDisplayManager displayManager;
+        virtioGpu::ctrlHdr sendHdr {virtioGpu::ctrlType::cmd::GET_DISPLAY_INFO};
+        virtioGpu::respDisplayInfo displayInfo;
+        virtioAdapter.prepareCommand(&sendHdr, sizeof(sendHdr), &displayInfo, virtioGpu::respDisplayInfo::size(TST_VIOGPU_MAX_SCANOUTS), virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+
+        WHEN("The command handler is created with attachDisplayLater set to false and GET_DISPLAY_INFO is called") {
+            VirtioGpuCmdHandler handler(virtioAdapter, displayManager, memoryAdapter, TST_VIOGPU_MAX_SCANOUTS, false);
+            handler.handleBuffer(&virtqBuf);
+
+            THEN("Display 0 is enabled, has the initial resolution and is attached") {
+                REQUIRE(displayInfo.hdr.uType == virtioGpu::ctrlType::resp::OK_DISPLAY_INFO);
+                REQUIRE(displayInfo.pmodes[0].enabled != 0);
+                REQUIRE(displayInfo.pmodes[0].r.width == virtioGpu::INITIAL_WIDTH);
+                REQUIRE(displayInfo.pmodes[0].r.height == virtioGpu::INITIAL_HEIGHT);
+                REQUIRE(displayManager.display(0)->fAttached == true);
+            }
+        }
+
+        WHEN("The command handler is created with attachDisplayLater set to true and GET_DISPLAY_INFO is called") {
+            VirtioGpuCmdHandler handler(virtioAdapter, displayManager, memoryAdapter, TST_VIOGPU_MAX_SCANOUTS, true);
+            handler.handleBuffer(&virtqBuf);
+
+            THEN("Display 0 is enabled and has the initial resolution, but the display is not attached") {
+                // We do this because if a driver attaches later to the virtio-gpu but immerdiately asks for the display info,
+                // the driver should still see all available scanouts.
+                REQUIRE(displayInfo.hdr.uType == virtioGpu::ctrlType::resp::OK_DISPLAY_INFO);
+                REQUIRE(displayInfo.pmodes[0].enabled != 0);
+                REQUIRE(displayInfo.pmodes[0].r.width == virtioGpu::INITIAL_WIDTH);
+                REQUIRE(displayInfo.pmodes[0].r.height == virtioGpu::INITIAL_HEIGHT);
+                REQUIRE(displayManager.display(0)->fAttached == false);
+            }
+        }
+    }
+}
+
+SCENARIO("Creation and deletion of resources is handled correctly") {
+    GIVEN("A fresh command handler") {
+        tstDisplayManager displayManager;
+        VirtioGpuCmdHandler handler(virtioAdapter, displayManager, memoryAdapter, TST_VIOGPU_MAX_SCANOUTS, false);
+
+        WHEN("A resource with ID 0 should be allocated") {
+            virtioGpu::ctrlHdr recvHdr;
+            virtioGpu::resourceCreate2d createResource {0u};
+
+            virtioAdapter.prepareCommand(&createResource, &recvHdr, virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+            handler.handleBuffer(&virtqBuf);
+
+            THEN("ERR_INVALID_RESOURCE_ID is returned.") {
+                // The driver disables a scanout be using the resource ID 0 in SET_SCANOUT.
+                // Thus the cmd handler should not allocate resources with ID 0.
+                REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::ERR_INVALID_RESOURCE_ID);
+            }
+        }
+
+        WHEN("A resource with a valid ID is allocated") {
+            virtioGpu::ctrlHdr recvHdr;
+            virtioGpu::resourceCreate2d createResource {RESOURCE_ID_ONE, RESOURCE_WIDTH, RESOURCE_HEIGHT};
+
+            virtioAdapter.prepareCommand(&createResource, &recvHdr, virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+            handler.handleBuffer(&virtqBuf);
+
+            THEN("OK_NODATA is returned.") {
+                REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::OK_NODATA);
+            }
+
+            AND_WHEN("A resource with the same ID is allocated") {
+                recvHdr.uType = 0;
+
+                virtioAdapter.prepareCommand(&createResource, &recvHdr, virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+                handler.handleBuffer(&virtqBuf);
+
+                THEN("ERR_INVALID_RESOURCE_ID is returned.") {
+                    REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::ERR_INVALID_RESOURCE_ID);
+                }
+            }
+
+            AND_WHEN("The resource is deleted") {
+                recvHdr.uType = 0;
+                virtioGpu::resourceUnref unrefResource {RESOURCE_ID_ONE};
+
+                virtioAdapter.prepareCommand(&unrefResource, &recvHdr, virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+                handler.handleBuffer(&virtqBuf);
+
+                THEN("OK_NODATA is returned.") {
+                    REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::OK_NODATA);
+                }
+
+                AND_WHEN("The resource is deleted again") {
+                    recvHdr.uType = 0;
+
+                    virtioAdapter.prepareCommand(&unrefResource, &recvHdr, virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+                    handler.handleBuffer(&virtqBuf);
+
+                    THEN("ERR_INVALID_RESOURCE_ID is returned") {
+                        REQUIRE(recvHdr.uType == virtioGpu::ctrlType::resp::ERR_INVALID_RESOURCE_ID);
+                    }
+                }
+            }
+        }
+    }
+}
+
+SCENARIO("Complex tests") {
+    GIVEN("A command handler with two resources with IDs 1 and 2 and attached backings to both resources") {
+        tstDisplayManager displayManager;
+        VirtioGpuCmdHandler handler(virtioAdapter, displayManager, memoryAdapter, TST_VIOGPU_MAX_SCANOUTS, false);
+
+        // 'Simple', because I just put in the two pointers
+        auto runSimpleCommand = [&handler](auto* pSend, auto* pRecv) -> void {
+            pRecv->hdr.uType = 0;
+            virtioAdapter.prepareCommand(pSend, pRecv, virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+            handler.handleBuffer(&virtqBuf);
+        };
+
+        auto runSimpleCommandAndCheck = [&handler, &runSimpleCommand](auto* pSend, auto* pRecv,
+                    virtioGpu::ctrlType::resp response = virtioGpu::ctrlType::resp::OK_NODATA) -> void {
+            runSimpleCommand(pSend, pRecv);
+            REQUIRE(pRecv->hdr.uType == response);
+        };
+
+        // 'Complex', because I have to provide the size
+        auto runComplexCommand = [&handler](void* pSend, size_t cbSend, auto* pRecv) -> void {
+            pRecv->hdr.uType = 0;
+            virtioAdapter.prepareCommand(pSend, cbSend, pRecv, sizeof(*pRecv), virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+            handler.handleBuffer(&virtqBuf);
+        };
+
+        auto runComplexCommandAndCheck = [&handler, &runComplexCommand](void* pSend, size_t cbSend, auto* pRecv,
+                    virtioGpu::ctrlType::resp response = virtioGpu::ctrlType::resp::OK_NODATA) -> void {
+            runComplexCommand(pSend, cbSend, pRecv);
+            REQUIRE(pRecv->hdr.uType == response);
+        };
+
+        struct { virtioGpu::ctrlHdr hdr; } recvHdr;
+        virtioGpu::respDisplayInfo recvDisplayInfo;
+
+        virtioGpu::ctrlHdr getDisplayInfo {virtioGpu::ctrlType::cmd::GET_DISPLAY_INFO};
+
+        virtioGpu::resourceCreate2d createResourceOne {RESOURCE_ID_ONE, RESOURCE_WIDTH, RESOURCE_HEIGHT};
+        virtioGpu::setScanout setScanoutOne {SCANOUT_ID_ONE, RESOURCE_ID_ONE, RESOURCE_WIDTH, RESOURCE_HEIGHT};
+        virtioGpu::setScanout disableScanoutOne {SCANOUT_ID_ONE, 0u};
+        virtioGpu::transferToHost2d transfer2HostOne {RESOURCE_ID_ONE, RESOURCE_WIDTH, RESOURCE_HEIGHT};
+        virtioGpu::resourceDetachBacking detachBackingOne {RESOURCE_ID_ONE};
+
+        virtioGpu::resourceCreate2d createResourceTwo {RESOURCE_ID_TWO, RESOURCE_WIDTH, RESOURCE_HEIGHT};
+        virtioGpu::setScanout setScanoutTwo {SCANOUT_ID_TWO, RESOURCE_ID_TWO, RESOURCE_WIDTH, RESOURCE_HEIGHT};
+        virtioGpu::transferToHost2d transfer2HostTwo {RESOURCE_ID_TWO, RESOURCE_WIDTH, RESOURCE_HEIGHT};
+
+        std::vector<void*> backingPagesOne;
+        std::vector<uint8_t> attachBackingMemOne;
+        virtioGpu::resourceAttachBacking* pAttachBackingOne;
+        virtioGpu::resourceMemEntry* pMemEntriesOne;
+
+        std::vector<void*> backingPagesTwo;
+        std::vector<uint8_t> attachBackingMemTwo;
+        virtioGpu::resourceAttachBacking* pAttachBackingTwo;
+        virtioGpu::resourceMemEntry* pMemEntriesTwo;
+
+        const uint8_t FRAME_BYTE_ONE {0x55};
+        const uint8_t FRAME_BYTE_TWO {0xaa};
+        auto initializeBacking = [](std::vector<uint8_t>& attachBackingMem,
+                                    std::vector<void*>& backingPages,
+                                    virtioGpu::resourceAttachBacking*& pAttachBacking,
+                                    virtioGpu::resourceMemEntry*& pMemEntries,
+                                    uint32_t uResourceId, uint8_t frame_byte) {
+            attachBackingMem.resize(ATTACH_BACKING_STRUCT_SIZE);
+            pAttachBacking = reinterpret_cast<virtioGpu::resourceAttachBacking*>(attachBackingMem.data());
+            pMemEntries = reinterpret_cast<virtioGpu::resourceMemEntry*>(attachBackingMem.data()+sizeof(virtioGpu::resourceAttachBacking));
+            pAttachBacking->hdr.uType = virtioGpu::ctrlType::cmd::RESOURCE_ATTACH_BACKING;
+            pAttachBacking->uResourceId = uResourceId;
+            pAttachBacking->uNrEntries = NUM_BACKINGS;
+
+            for (auto idx {0u}; idx < NUM_BACKINGS; idx++) {
+                void* backingPtr {RTMemAlloc(BACKING_SIZE)};
+                backingPages.emplace_back(backingPtr);
+
+                pMemEntries[idx].uAddr = reinterpret_cast<uint64_t>(backingPtr);
+                pMemEntries[idx].uLength = BACKING_SIZE;
+
+                std::memset(backingPages.at(idx), frame_byte, BACKING_SIZE);
+            }
+        };
+
+        initializeBacking(attachBackingMemOne, backingPagesOne, pAttachBackingOne, pMemEntriesOne, RESOURCE_ID_ONE, FRAME_BYTE_ONE);
+        initializeBacking(attachBackingMemTwo, backingPagesTwo, pAttachBackingTwo, pMemEntriesTwo, RESOURCE_ID_TWO, FRAME_BYTE_TWO);
+
+        auto frameBufPage = [&displayManager](int32_t displayIdx, size_t idx) -> void* {
+            if (displayManager.display(displayIdx)->pFrameBuffer() == nullptr) {
+                return nullptr;
+            }
+            return reinterpret_cast<uint8_t*>(displayManager.display(displayIdx)->pFrameBuffer())+idx*BACKING_SIZE;
+        };
+
+        // Returns true if the framebuffer and the backing have the same values in them
+        auto compareFramebufBacking = [&frameBufPage](std::vector<void*> backingPages, uint32_t displayIdx) -> bool {
+            if (frameBufPage(displayIdx, 0) == nullptr) {
+                return false;
+            }
+
+            std::vector<int> results;
+            for (auto idx {0u}; idx < NUM_BACKINGS; idx++) {
+                results.emplace_back(std::memcmp(backingPages.at(idx), frameBufPage(displayIdx, idx), BACKING_SIZE));
+            }
+            return std::all_of(std::begin(results), std::end(results), [](int res) { return res == 0; });
+        };
+
+        runSimpleCommandAndCheck(&createResourceOne, &recvHdr);
+        runComplexCommandAndCheck(pAttachBackingOne, ATTACH_BACKING_STRUCT_SIZE, &recvHdr);
+
+        runSimpleCommandAndCheck(&createResourceTwo, &recvHdr);
+        runComplexCommandAndCheck(pAttachBackingTwo, ATTACH_BACKING_STRUCT_SIZE, &recvHdr);
+
+        /*
+         * TESTING - SINGLE MONITOR
+         */
+
+        WHEN("TRANSFER_2_HOST is called") {
+            runSimpleCommand(&transfer2HostOne, &recvHdr);
+
+            THEN("The scanout is enabled and has its initial width and height") {
+                REQUIRE(displayManager.display(0)->fAttached == true);
+                REQUIRE(displayManager.display(0)->uCurrentWidth == virtioGpu::INITIAL_WIDTH);
+                REQUIRE(displayManager.display(0)->uCurrentHeight == virtioGpu::INITIAL_HEIGHT);
+            }
+
+            AND_THEN("The transferring fails because no scanout is assigned to the resource") {
+                REQUIRE(recvHdr.hdr.uType == virtioGpu::ctrlType::resp::ERR_INVALID_RESOURCE_ID);
+                REQUIRE(not compareFramebufBacking(backingPagesOne, SCANOUT_ID_ONE));
+            }
+        }
+
+        WHEN("SET_SCANOUT is called with the resource Id of an existing resource") {
+            runSimpleCommandAndCheck(&setScanoutOne, &recvHdr);
+
+            THEN("The scanout is enabled and has the given dimension") {
+                REQUIRE(displayManager.display(0)->fAttached == true);
+                REQUIRE(displayManager.display(0)->uCurrentWidth == RESOURCE_WIDTH);
+                REQUIRE(displayManager.display(0)->uCurrentHeight == RESOURCE_HEIGHT);
+            }
+
+            AND_WHEN("SET_SCANOUT is called with a resource Id of 0") {
+                runSimpleCommand(&disableScanoutOne, &recvHdr);
+
+                THEN("The scanout is disabled") {
+                    REQUIRE(displayManager.display(0)->fAttached == false);
+                }
+            }
+
+            AND_WHEN("TRANSFER_2_HOST ist called") {
+                runSimpleCommandAndCheck(&transfer2HostOne, &recvHdr);
+
+                THEN("The transferring is successful") {
+                    REQUIRE(compareFramebufBacking(backingPagesOne, SCANOUT_ID_ONE));
+                }
+            }
+
+            AND_WHEN("DETACH_BACKING and TRANSFER_2_HOST are called") {
+                // we again want to compare the framebuffer and the backing, thus we have to clear the framebuffer
+                std::memset(displayManager.display(0)->pFrameBuffer(), 0, displayManager.display(0)->cbFrameBuffer());
+
+                runSimpleCommandAndCheck(&detachBackingOne, &recvHdr);
+                runSimpleCommandAndCheck(&transfer2HostOne, &recvHdr);
+
+                THEN("No data is transferred") {
+                    REQUIRE(not compareFramebufBacking(backingPagesOne, SCANOUT_ID_ONE));
+                }
+            }
+
+            AND_THEN("GET_DISPLAY_INFO also reports the given resolution") {
+                virtioAdapter.prepareCommand(&getDisplayInfo, sizeof(getDisplayInfo), &recvDisplayInfo, virtioGpu::respDisplayInfo::size(TST_VIOGPU_MAX_SCANOUTS), virtioGpu::virtqIdx::CONTROLQ, &virtqBuf);
+                handler.handleBuffer(&virtqBuf);
+                REQUIRE(recvDisplayInfo.hdr.uType == virtioGpu::ctrlType::resp::OK_DISPLAY_INFO);
+
+                REQUIRE(recvDisplayInfo.pmodes[0].enabled != 0);
+                REQUIRE(recvDisplayInfo.pmodes[0].r.width == RESOURCE_WIDTH);
+                REQUIRE(recvDisplayInfo.pmodes[0].r.height == RESOURCE_HEIGHT);
+            }
+
+            AND_WHEN("requestResize is called because the screen has changed") {
+                handler.requestResize(0, RESIZED_WIDTH, RESIZED_HEIGHT);
+
+                THEN("the display reports still the same size") {
+                    REQUIRE(displayManager.display(0)->uCurrentWidth == RESOURCE_WIDTH);
+                    REQUIRE(displayManager.display(0)->uCurrentHeight == RESOURCE_HEIGHT);
+                }
+
+                AND_WHEN("GET_DISPLAY_INFO is used to receive the new resolution") {
+                    runSimpleCommandAndCheck(&getDisplayInfo, &recvDisplayInfo, virtioGpu::ctrlType::resp::OK_DISPLAY_INFO);
+
+                    THEN("the driver receives the new resolution and the display reports the new size") {
+                        REQUIRE(recvDisplayInfo.pmodes[0].enabled != 0);
+                        REQUIRE(recvDisplayInfo.pmodes[0].r.width == RESIZED_WIDTH);
+                        REQUIRE(recvDisplayInfo.pmodes[0].r.height == RESIZED_HEIGHT);
+                        REQUIRE(displayManager.display(0)->uCurrentWidth == RESIZED_WIDTH);
+                        REQUIRE(displayManager.display(0)->uCurrentHeight == RESIZED_HEIGHT);
+                    }
+                }
+            }
+        }
+
+        /*
+         * TESTING - MULTI MONITOR
+         */
+
+        // Mirroring
+        WHEN("A single framebuffer is linked to two monitors and TRANSFER_TO_HOST is called") {
+            virtioGpu::setScanout setScanoutTwo2One {SCANOUT_ID_TWO, RESOURCE_ID_ONE, RESOURCE_WIDTH, RESOURCE_HEIGHT};
+            runSimpleCommandAndCheck(&setScanoutOne, &recvDisplayInfo);
+            runSimpleCommandAndCheck(&setScanoutTwo2One, &recvDisplayInfo);
+
+            runSimpleCommandAndCheck(&transfer2HostOne, &recvHdr);
+
+            THEN("Both scanouts have the same data in their framebuffers") {
+                REQUIRE(compareFramebufBacking(backingPagesOne, SCANOUT_ID_ONE));
+                REQUIRE(compareFramebufBacking(backingPagesOne, SCANOUT_ID_TWO));
+            }
+        }
+
+        // Join Displays 1
+        WHEN("Different framebuffers are linked to two monitors and TRANSFER_TO_HOST is called") {
+            runSimpleCommandAndCheck(&setScanoutOne, &recvDisplayInfo);
+            runSimpleCommandAndCheck(&setScanoutTwo, &recvDisplayInfo);
+
+            runSimpleCommandAndCheck(&transfer2HostOne, &recvHdr);
+            runSimpleCommandAndCheck(&transfer2HostTwo, &recvHdr);
+
+            THEN("Both scanouts have the expected data in their framebuffers") {
+                REQUIRE(compareFramebufBacking(backingPagesOne, SCANOUT_ID_ONE));
+                REQUIRE(compareFramebufBacking(backingPagesTwo, SCANOUT_ID_TWO));
+            }
+        }
+    }
+}
diff --git a/src/VBox/Frontends/VBoxManage/VBoxManageInfo.cpp b/src/VBox/Frontends/VBoxManage/VBoxManageInfo.cpp
index fffa353734..3381669b3c 100644
--- a/src/VBox/Frontends/VBoxManage/VBoxManageInfo.cpp
+++ b/src/VBox/Frontends/VBoxManage/VBoxManageInfo.cpp
@@ -1457,6 +1457,18 @@ HRESULT showVMInfo(ComPtr<IVirtualBox> pVirtualBox,
                 else
                     pszCtrl = "VBoxSVGA";
                 break;
+            case GraphicsControllerType_VGAWithVirtioGpu:
+                if (details == VMINFO_MACHINEREADABLE)
+                    pszCtrl = "vga-virtiogpu";
+                else
+                    pszCtrl = "VGAWithVirtioGPU";
+                break;
+            case GraphicsControllerType_VirtioGpu:
+                if (details == VMINFO_MACHINEREADABLE)
+                    pszCtrl = "virtiogpu";
+                else
+                    pszCtrl = "VirtioGPU";
+                break;
             default:
                 if (details == VMINFO_MACHINEREADABLE)
                     pszCtrl = "unknown";
diff --git a/src/VBox/Frontends/VBoxManage/VBoxManageModifyVM.cpp b/src/VBox/Frontends/VBoxManage/VBoxManageModifyVM.cpp
index aa3ecf7986..ce922b008c 100644
--- a/src/VBox/Frontends/VBoxManage/VBoxManageModifyVM.cpp
+++ b/src/VBox/Frontends/VBoxManage/VBoxManageModifyVM.cpp
@@ -1005,6 +1005,12 @@ RTEXITCODE handleModifyVM(HandlerArg *a)
                          || !RTStrICmp(ValueUnion.psz, "svga"))
                     CHECK_ERROR(pGraphicsAdapter, COMSETTER(GraphicsControllerType)(GraphicsControllerType_VBoxSVGA));
 #endif
+                else if (   !RTStrICmp(ValueUnion.psz, "vga-virtiogpu")) {
+                    CHECK_ERROR(pGraphicsAdapter, COMSETTER(GraphicsControllerType)(GraphicsControllerType_VGAWithVirtioGpu));
+                }
+                else if (   !RTStrICmp(ValueUnion.psz, "virtiogpu")) {
+                    CHECK_ERROR(pGraphicsAdapter, COMSETTER(GraphicsControllerType)(GraphicsControllerType_VirtioGpu));
+                }
                 else
                 {
                     errorArgument(ModifyVM::tr("Invalid --graphicscontroller argument '%s'"), ValueUnion.psz);
diff --git a/src/VBox/Frontends/VirtualBox/src/converter/UIConverterBackendCOM.cpp b/src/VBox/Frontends/VirtualBox/src/converter/UIConverterBackendCOM.cpp
index 3799bcab84..f5da2c826a 100644
--- a/src/VBox/Frontends/VirtualBox/src/converter/UIConverterBackendCOM.cpp
+++ b/src/VBox/Frontends/VirtualBox/src/converter/UIConverterBackendCOM.cpp
@@ -316,6 +316,8 @@ template<> QString toString(const KGraphicsControllerType &type)
         case KGraphicsControllerType_VBoxVGA:  return QApplication::translate("UICommon", "VBoxVGA",  "GraphicsControllerType");
         case KGraphicsControllerType_VMSVGA:   return QApplication::translate("UICommon", "VMSVGA",   "GraphicsControllerType");
         case KGraphicsControllerType_VBoxSVGA: return QApplication::translate("UICommon", "VBoxSVGA", "GraphicsControllerType");
+        case KGraphicsControllerType_VGAWithVirtioGpu: return QApplication::translate("UICommon", "VGAWithVirtioGPU", "GraphicsControllerType");
+        case KGraphicsControllerType_VirtioGpu: return QApplication::translate("UICommon", "VirtioGPU", "GraphicsControllerType");
         default: AssertMsgFailed(("No text for %d", type)); break;
     }
     return QString();
@@ -329,6 +331,8 @@ template<> KGraphicsControllerType fromString<KGraphicsControllerType>(const QSt
     list.insert(QApplication::translate("UICommon", "VBoxVGA",  "GraphicsControllerType"), KGraphicsControllerType_VBoxVGA);
     list.insert(QApplication::translate("UICommon", "VMSVGA",   "GraphicsControllerType"), KGraphicsControllerType_VMSVGA);
     list.insert(QApplication::translate("UICommon", "VBoxSVGA", "GraphicsControllerType"), KGraphicsControllerType_VBoxSVGA);
+    list.insert(QApplication::translate("UICommon", "VGAWithVirtioGPU", "GraphicsControllerType"), KGraphicsControllerType_VGAWithVirtioGpu);
+    list.insert(QApplication::translate("UICommon", "VirtioGPU", "GraphicsControllerType"), KGraphicsControllerType_VirtioGpu);
     if (!list.contains(strType))
     {
         AssertMsgFailed(("No value for '%s'", strType.toUtf8().constData()));
diff --git a/src/VBox/Main/idl/VirtualBox.xidl b/src/VBox/Main/idl/VirtualBox.xidl
index 26e9d94aa0..ad6b2dd395 100644
--- a/src/VBox/Main/idl/VirtualBox.xidl
+++ b/src/VBox/Main/idl/VirtualBox.xidl
@@ -6536,6 +6536,12 @@
     <const name="VBoxSVGA"  value="3">
       <desc>VirtualBox VGA device with VMware SVGA II extensions.</desc>
     </const>
+    <const name="VGAWithVirtioGpu" value="7">
+      <desc>Virtualbox VGA device for the boot screen switching to Intel HD Graphics.</desc>
+    </const>
+    <const name="VirtioGpu" value="8">
+      <desc>Intel HD Graphics with hardware acceleration.</desc>
+    </const>
   </enum>
 
   <enum
diff --git a/src/VBox/Main/include/ConsoleImpl.h b/src/VBox/Main/include/ConsoleImpl.h
index e1fc1f9b4d..6c35170064 100644
--- a/src/VBox/Main/include/ConsoleImpl.h
+++ b/src/VBox/Main/include/ConsoleImpl.h
@@ -729,7 +729,8 @@ private:
                                    const ComPtr<IMachine> &ptrMachine,
                                    const ComPtr<IGraphicsAdapter> &ptrGraphicsAdapter,
                                    const ComPtr<IBIOSSettings> &ptrBiosSettings,
-                                   bool fHMEnabled);
+                                   bool fHMEnabled,
+                                   bool fHideMultipleMonitors = false);
     int i_checkMediumLocation(IMedium *pMedium, bool *pfUseHostIOCache);
     int i_unmountMediumFromGuest(PUVM pUVM, PCVMMR3VTABLE pVMM, StorageBus_T enmBus, DeviceType_T enmDevType,
                                  const char *pcszDevice, unsigned uInstance, unsigned uLUN,
@@ -808,6 +809,10 @@ private:
 
     HRESULT i_attachRawPCIDevices(PUVM pUVM, BusAssignmentManager *BusMgr, PCFGMNODE pDevices);
     HRESULT i_attachVfioDevices(BusAssignmentManager *BusMgr, PCFGMNODE pDevices, PCVMMR3VTABLE pVMM);
+    HRESULT i_attachVirtioGpuDevice(BusAssignmentManager *BusMgr,
+                                    PCFGMNODE pDevices,
+                                    const ComPtr<IGraphicsAdapter> &ptrGraphicsAdapter,
+                                    bool secondaryController);
     struct LEDSET;
     typedef struct LEDSET *PLEDSET;
     PPDMLED volatile *i_getLedSet(uint32_t iLedSet);
diff --git a/src/VBox/Main/src-client/BusAssignmentManager.cpp b/src/VBox/Main/src-client/BusAssignmentManager.cpp
index b4665d696c..1085b52865 100644
--- a/src/VBox/Main/src-client/BusAssignmentManager.cpp
+++ b/src/VBox/Main/src-client/BusAssignmentManager.cpp
@@ -120,7 +120,9 @@ static const DeviceAssignmentRule g_aGenericRules[] =
     {"vfio",           0, 16,  0, 1},
     {"vfio",           0, 17,  0, 1},
     {"vfio",           0, 18,  0, 1},
-    {"vfio",           0, 19,  0, 1},
+
+    /* Virtio-Gpu */
+    {"virtio-gpu",     0, 19,  0, 1},
 
     /* ISA/LPC controller */
     {"lpc",           0, 31,  0, 0},
diff --git a/src/VBox/Main/src-client/ConsoleImpl2.cpp b/src/VBox/Main/src-client/ConsoleImpl2.cpp
index 7a4ee5db5f..b571253e26 100644
--- a/src/VBox/Main/src-client/ConsoleImpl2.cpp
+++ b/src/VBox/Main/src-client/ConsoleImpl2.cpp
@@ -674,7 +674,7 @@ HRESULT Console::i_attachRawPCIDevices(PUVM pUVM, BusAssignmentManager *pBusMgr,
 #endif
 
 
-HRESULT Console::i_attachVfioDevices(BusAssignmentManager *pBusMgr, PCFGMNODE pDevices, PCVMMR3VTABLE pVMM)
+HRESULT Console::i_attachVfioDevices(BusAssignmentManager *pBusMgr, PCFGMNODE pDevices, PCVMMR3VTABLE /*pVMM*/)
 {
     HRESULT hrc {S_OK};
     PCFGMNODE pInst{NULL};
@@ -734,6 +734,39 @@ HRESULT Console::i_attachVfioDevices(BusAssignmentManager *pBusMgr, PCFGMNODE pD
     return hrc;
 }
 
+HRESULT Console::i_attachVirtioGpuDevice(BusAssignmentManager *pBusMgr,
+                                         PCFGMNODE pDevices,
+                                         const ComPtr<IGraphicsAdapter> &ptrGraphicsAdapter,
+                                         bool secondaryController)
+{
+    PCFGMNODE pInst {NULL};
+    PCFGMNODE pVirtioGpuDev {NULL};
+
+    InsertConfigNode(pDevices, "virtio-gpu", &pVirtioGpuDev);
+    InsertConfigNode(pVirtioGpuDev, "0", &pInst);
+    InsertConfigInteger(pInst, "Trusted", 1);
+
+    PCFGMNODE pCfg {NULL};
+    PCFGMNODE pLunL0 {NULL};
+
+    InsertConfigNode(pInst,    "Config", &pCfg);
+    InsertConfigInteger(pCfg, "secondaryController", secondaryController);
+
+    unsigned cMonitorCount {0};
+    auto hrc = ptrGraphicsAdapter->COMGETTER(MonitorCount)(&cMonitorCount); H();
+    InsertConfigInteger(pCfg, "MonitorCount", cMonitorCount);
+
+    unsigned cVRamMBs;
+    hrc = ptrGraphicsAdapter->COMGETTER(VRAMSize)(&cVRamMBs);               H();
+    InsertConfigInteger(pCfg,  "VRamSize", cVRamMBs * _1M);
+
+    InsertConfigNode(pInst, "LUN#0", &pLunL0);
+    InsertConfigString(pLunL0, "Driver", "MainDisplay");
+    InsertConfigNode(pLunL0, "Config", &pCfg);
+
+    return pBusMgr->assignPCIDevice("virtio-gpu", pInst);
+}
+
 /**
  * Updates the device type for a LED.
  *
@@ -1482,6 +1515,26 @@ int Console::i_configConstructorInner(PUVM pUVM, PVM pVM, PCVMMR3VTABLE pVMM, Au
         bool         fGimDebug          = false;
         com::Utf8Str strGimDebugAddress = "127.0.0.1";
         uint32_t     uGimDebugPort      = 50000;
+
+        PCFGMNODE pHvNode;
+        InsertConfigNode(pParavirtNode, "HyperV", &pHvNode);
+
+        {
+            ComPtr<IGraphicsAdapter> pGraphicsAdapter;
+            hrc = pMachine->COMGETTER(GraphicsAdapter)(pGraphicsAdapter.asOutParam());           H();
+            GraphicsControllerType_T enmGraphicsController;
+            hrc = pGraphicsAdapter->COMGETTER(GraphicsControllerType)(&enmGraphicsController);          H();
+
+            switch (enmGraphicsController) {
+            case GraphicsControllerType_VirtioGpu:
+            case GraphicsControllerType_VGAWithVirtioGpu:
+                InsertConfigInteger(pHvNode, "VirtioGPU", true);
+                break;
+            default:
+                break;
+            }
+        }
+
         if (strParavirtDebug.isNotEmpty())
         {
             /* Hyper-V debug options. */
@@ -1534,8 +1587,6 @@ int Console::i_configConstructorInner(PUVM pUVM, PVM pVM, PCVMMR3VTABLE pVMM, Au
                 /* Update HyperV CFGM node with active debug options. */
                 if (fGimHvDebug)
                 {
-                    PCFGMNODE pHvNode;
-                    InsertConfigNode(pParavirtNode, "HyperV", &pHvNode);
                     InsertConfigString(pHvNode,  "VendorID", strGimHvVendor);
                     InsertConfigInteger(pHvNode, "VSInterface", fGimHvVsIf ? 1 : 0);
                     InsertConfigInteger(pHvNode, "HypercallDebugInterface", fGimHvHypercallIf ? 1 : 0);
@@ -1984,6 +2035,23 @@ int Console::i_configConstructorInner(PUVM pUVM, PVM pVM, PCVMMR3VTABLE pVMM, Au
                 if (FAILED(vrc))
                     return vrc;
                 break;
+            case GraphicsControllerType_VGAWithVirtioGpu:
+                hrc = i_attachVirtioGpuDevice(pBusMgr, pDevices, pGraphicsAdapter, true);
+                if (FAILED(hrc)) {
+                    return hrc;
+                }
+                // See case GraphicsControllerType_VGAWithIntelGVT
+                hrc = i_configGraphicsController(pDevices, GraphicsControllerType_VBoxSVGA, pBusMgr, pMachine, pGraphicsAdapter, biosSettings,
+                                                RT_BOOL(fHMEnabled), true);
+                if (FAILED(hrc))
+                    return hrc;
+                break;
+            case GraphicsControllerType_VirtioGpu:
+                hrc = i_attachVirtioGpuDevice(pBusMgr, pDevices, pGraphicsAdapter, false);
+                if (FAILED(hrc)) {
+                    return hrc;
+                }
+                break;
             default:
                 AssertMsgFailed(("Invalid graphicsController=%d\n", enmGraphicsController));
                 return pVMM->pfnVMR3SetError(pUVM, VERR_INVALID_PARAMETER, RT_SRC_POS,
@@ -4374,7 +4442,8 @@ int Console::i_configGraphicsController(PCFGMNODE pDevices,
                                         const ComPtr<IMachine> &ptrMachine,
                                         const ComPtr<IGraphicsAdapter> &ptrGraphicsAdapter,
                                         const ComPtr<IBIOSSettings> &ptrBiosSettings,
-                                        bool fHMEnabled)
+                                        bool fHMEnabled,
+                                        bool fHideMultipleMonitors)
 {
     // InsertConfig* throws
     try
@@ -4391,11 +4460,24 @@ int Console::i_configGraphicsController(PCFGMNODE pDevices,
 
         hrc = pBusMgr->assignPCIDevice(pcszDevice, pInst);                                  H();
         InsertConfigNode(pInst,    "Config", &pCfg);
-        ULONG cVRamMBs;
-        hrc = ptrGraphicsAdapter->COMGETTER(VRAMSize)(&cVRamMBs);                           H();
-        InsertConfigInteger(pCfg,  "VRamSize",             cVRamMBs * _1M);
+        ULONG cVRam;
+        hrc = ptrGraphicsAdapter->COMGETTER(VRAMSize)(&cVRam);                              H();
+        InsertConfigInteger(pCfg,  "VRamSize",             cVRam * _1M);
         ULONG cMonitorCount;
-        hrc = ptrGraphicsAdapter->COMGETTER(MonitorCount)(&cMonitorCount);                  H();
+
+        /**
+         * If the Virtio GPU is used with multiple monitors we hide additional
+         * monitors for the VirtualBox VGA adapter that is used for the legacy
+         * output, as the legacy output does not require multiple monitors.
+         * This leads to the multiple monitors appearing when we switch to the
+         * Virtio GPU.
+         */
+        if (not fHideMultipleMonitors)
+        {
+            hrc = ptrGraphicsAdapter->COMGETTER(MonitorCount)(&cMonitorCount);              H();
+        } else {
+            cMonitorCount = 1;
+        }
         InsertConfigInteger(pCfg,  "MonitorCount",         cMonitorCount);
 #ifdef VBOX_WITH_2X_4GB_ADDR_SPACE
         InsertConfigInteger(pCfg,  "R0Enabled",            fHMEnabled);
diff --git a/src/VBox/Main/src-client/DisplayImpl.cpp b/src/VBox/Main/src-client/DisplayImpl.cpp
index 5a4beefebb..1f236d913d 100644
--- a/src/VBox/Main/src-client/DisplayImpl.cpp
+++ b/src/VBox/Main/src-client/DisplayImpl.cpp
@@ -65,6 +65,9 @@
 # include <VBox/vmm/pdmaudioifs.h>
 #endif
 
+#include <VBox/vmm/pdmdev.h>
+#include <VBox/com/errorprint.h>
+
 /**
  * Display driver instance data.
  *
@@ -2330,7 +2333,12 @@ HRESULT Display::drawToScreen(ULONG aScreenId, BYTE *aAddress, ULONG aX, ULONG a
 
         if (   !pFBInfo->fVBVAEnabled
             && uScreenId == VBOX_VIDEO_PRIMARY_SCREEN)
+        {
+            if (not pDisplay->mpDrv) {
+                return VINF_SUCCESS;
+            }
             pDisplay->mpDrv->pUpPort->pfnUpdateDisplayAll(pDisplay->mpDrv->pUpPort, /* fFailOnResize = */ true);
+        }
         else
         {
             if (!pFBInfo->fDisabled)
@@ -2664,6 +2672,39 @@ HRESULT Display::setScreenLayout(ScreenLayoutMode_T aScreenLayoutMode,
                         p->fDisplayFlags |= VMMDEV_DISPLAY_PRIMARY;
                 }
 
+                auto virtioGpuEnabled = [this]() -> bool {
+                    ComPtr<IGraphicsAdapter> pGraphicsAdapter;
+                    HRESULT hrc = mParent->i_machine()->COMGETTER(GraphicsAdapter)(pGraphicsAdapter.asOutParam());
+                    AssertComRCReturnRC(hrc);
+
+                    GraphicsControllerType_T adapterType;
+                    CHECK_ERROR(pGraphicsAdapter, COMGETTER(GraphicsControllerType)(&adapterType));
+                    return (adapterType == GraphicsControllerType_VGAWithVirtioGpu) or
+                           (adapterType == GraphicsControllerType_VirtioGpu);
+                };
+
+                if (virtioGpuEnabled()) {
+                    AutoReadLock alock2(this COMMA_LOCKVAL_SRC_POS);
+                    Console::SafeVMPtr ptrVM(mParent);
+                    if (!ptrVM.isOk()) {
+                        LogRelFunc(("VMPtr is not okay.\n"));
+                        return ptrVM.hrc();
+                    }
+                    alock2.release();
+
+                    PPDMIBASE pBase;
+                    int rc = ptrVM.vtable()->pfnPDMR3QueryDevice(ptrVM.rawUVM(), "virtio-gpu", 0, &pBase);
+                    AssertReleaseMsg(RT_SUCCESS(rc), ("query device failed"));
+
+                    PPDMIVIRTIOGPUPORT pPort {PDMIBASE_QUERY_INTERFACE(pBase, PDMIVIRTIOGPUPORT)};
+                    AssertMsg(pPort, ("Query interface failed.\n"));
+                    AssertMsg(pPort->pfnDisplayChanged, ("No resize handler available.\n"));
+                    PPDMDEVINS pDevIns = PDMIBASE_2_PDMDEV(pBase);
+                    if (pPort->pfnDisplayChanged) {
+                        pPort->pfnDisplayChanged(pDevIns, cDisplays, paDisplayDefs);
+                    }
+                }
+
                 bool const fForce =    aScreenLayoutMode == ScreenLayoutMode_Reset
                                     || aScreenLayoutMode == ScreenLayoutMode_Apply;
                 bool const fNotify = aScreenLayoutMode != ScreenLayoutMode_Silent;
diff --git a/src/VBox/Main/src-server/GraphicsAdapterImpl.cpp b/src/VBox/Main/src-server/GraphicsAdapterImpl.cpp
index 759f4324ff..481d18a50f 100644
--- a/src/VBox/Main/src-server/GraphicsAdapterImpl.cpp
+++ b/src/VBox/Main/src-server/GraphicsAdapterImpl.cpp
@@ -198,6 +198,8 @@ HRESULT GraphicsAdapter::setGraphicsControllerType(GraphicsControllerType_T aGra
         case GraphicsControllerType_VMSVGA:
         case GraphicsControllerType_VBoxSVGA:
 #endif
+        case GraphicsControllerType_VGAWithVirtioGpu:
+        case GraphicsControllerType_VirtioGpu:
             break;
         default:
             return setError(E_INVALIDARG, tr("The graphics controller type (%d) is invalid"), aGraphicsControllerType);
diff --git a/src/VBox/Main/src-server/SystemPropertiesImpl.cpp b/src/VBox/Main/src-server/SystemPropertiesImpl.cpp
index c238ae37cf..cfee49e932 100644
--- a/src/VBox/Main/src-server/SystemPropertiesImpl.cpp
+++ b/src/VBox/Main/src-server/SystemPropertiesImpl.cpp
@@ -1687,6 +1687,8 @@ HRESULT SystemProperties::getSupportedGraphicsControllerTypes(std::vector<Graphi
         GraphicsControllerType_VBoxVGA,
         GraphicsControllerType_VMSVGA,
         GraphicsControllerType_VBoxSVGA,
+        GraphicsControllerType_VGAWithVirtioGpu,
+        GraphicsControllerType_VirtioGpu,
         GraphicsControllerType_Null,
     };
     aSupportedGraphicsControllerTypes.assign(aGraphicsControllerTypes,
diff --git a/src/VBox/Main/xml/Settings.cpp b/src/VBox/Main/xml/Settings.cpp
index e818eeb23f..bf4c7ae293 100644
--- a/src/VBox/Main/xml/Settings.cpp
+++ b/src/VBox/Main/xml/Settings.cpp
@@ -5433,6 +5433,10 @@ void MachineConfigFile::readHardware(const xml::ElementNode &elmHardware,
                     type = GraphicsControllerType_VMSVGA;
                 else if (strGraphicsControllerType == "VBOXSVGA")
                     type = GraphicsControllerType_VBoxSVGA;
+                else if (strGraphicsControllerType == "VGAWITHVIRTIOGPU")
+                    type = GraphicsControllerType_VGAWithVirtioGpu;
+                else if (strGraphicsControllerType == "VIRTIOGPU")
+                    type = GraphicsControllerType_VirtioGpu;
                 else if (strGraphicsControllerType == "NONE")
                     type = GraphicsControllerType_Null;
                 else
@@ -7174,6 +7178,8 @@ void MachineConfigFile::buildHardwareXML(xml::ElementNode &elmParent,
                 case GraphicsControllerType_VBoxVGA:            pcszGraphics = "VBoxVGA"; break;
                 case GraphicsControllerType_VMSVGA:             pcszGraphics = "VMSVGA"; break;
                 case GraphicsControllerType_VBoxSVGA:           pcszGraphics = "VBoxSVGA"; break;
+                case GraphicsControllerType_VGAWithVirtioGpu:   pcszGraphics = "VGAWithVirtioGPU"; break;
+                case GraphicsControllerType_VirtioGpu:   pcszGraphics = "VirtioGPU"; break;
                 default: /*case GraphicsControllerType_Null:*/  pcszGraphics = "None"; break;
             }
             pelmDisplay->setAttribute("controller", pcszGraphics);
diff --git a/src/VBox/Main/xml/VirtualBox-settings.xsd b/src/VBox/Main/xml/VirtualBox-settings.xsd
index 60f7303c5e..460c5e7907 100644
--- a/src/VBox/Main/xml/VirtualBox-settings.xsd
+++ b/src/VBox/Main/xml/VirtualBox-settings.xsd
@@ -289,6 +289,8 @@
     <xsd:enumeration value="VBoxVGA"/>
     <xsd:enumeration value="VMSVGA"/>
     <xsd:enumeration value="VBoxSVGA"/>
+    <xsd:enumeration value="VGAWithVirtioGPU"/>
+    <xsd:enumeration value="VirtioGPU"/>
   </xsd:restriction>
 </xsd:simpleType>
 
diff --git a/src/VBox/Runtime/VBox/log-vbox.cpp b/src/VBox/Runtime/VBox/log-vbox.cpp
index 9d9c5d731e..5b75d76fbe 100644
--- a/src/VBox/Runtime/VBox/log-vbox.cpp
+++ b/src/VBox/Runtime/VBox/log-vbox.cpp
@@ -273,6 +273,7 @@ RTDECL(PRTLOGGER) RTLogDefaultInit(void)
     ASSERT_LOG_GROUP(DEV_SERIAL);
     ASSERT_LOG_GROUP(DEV_SMC);
     ASSERT_LOG_GROUP(DEV_VFIO);
+    ASSERT_LOG_GROUP(DEV_VIRTIO_GPU);
     ASSERT_LOG_GROUP(DEV_VGA);
     ASSERT_LOG_GROUP(DEV_VIRTIO);
     ASSERT_LOG_GROUP(DEV_VIRTIO_NET);
diff --git a/src/VBox/VMM/VMMR3/GIMHv.cpp b/src/VBox/VMM/VMMR3/GIMHv.cpp
index 1da9065120..116045bb2f 100644
--- a/src/VBox/VMM/VMMR3/GIMHv.cpp
+++ b/src/VBox/VMM/VMMR3/GIMHv.cpp
@@ -239,7 +239,8 @@ VMMR3_INT_DECL(int) gimR3HvInit(PVM pVM, PCFGMNODE pGimCfg)
         int rc2 = CFGMR3ValidateConfig(pCfgHv, "/HyperV/",
                                   "VendorID"
                                   "|VSInterface"
-                                  "|HypercallDebugInterface",
+                                  "|HypercallDebugInterface"
+                                  "|VirtioGPU",
                                   "" /* pszValidNodes */, "GIM/HyperV" /* pszWho */, 0 /* uInstance */);
         if (RT_FAILURE(rc2))
             return rc2;
@@ -368,6 +369,17 @@ VMMR3_INT_DECL(int) gimR3HvInit(PVM pVM, PCFGMNODE pGimCfg)
                          ;
 #endif
 
+        bool withVirtioGPU {false};
+        rc = CFGMR3QueryBoolDef(pCfgHv, "VirtioGPU", &withVirtioGPU, false);
+
+        if (RT_SUCCESS(rc) and withVirtioGPU and pVM->cCpus > 8) {
+            LogRel(("Disabling the GIM_HV_HINT_X2APIC_MSRS HyperV hint because there are %d virtual CPUs and " \
+                    "the VirtioGPU is used as a graphics controller. More than 8 vCPUs are known to result in "
+                    "Windows10 not booting if the DVServerKMD driver is installed in the guest if the specific "
+                    "HyperV hint is set.\n", pVM->cCpus));
+            pHv->uHyperHints &= ~GIM_HV_HINT_X2APIC_MSRS;
+        }
+
         /* Partition features. */
 #ifdef VBOX_WITH_KVM
         /* Extended hypercalls require KVM_EXIT_HYPER_HCALL exits to be forwarded gimHvHypercall.
-- 
2.43.0

